## Подшаг 1.1: Валидация входных данных — подробный план реализации на C++

### Шаг 1.1.1: Определение структур данных для хранения входных множеств

**Организация контейнеров:**
- Создать три отдельных контейнера для хранения точек разных типов:
  - `std::vector<std::pair<double, double>> approx_points` — пары `(x_i, f(x_i))` с весами `σ_i`
  - `std::vector<std::pair<double, double>> repulse_points` — пары `(y_j, f(y_j))` с весами `B_j`
  - `std::vector<std::pair<double, double>> interp_nodes` — пары `(z_e, f(z_e))` без весов (обязательная интерполяция)
- Хранить веса в отдельных векторах или как третий элемент кортежа для явного разделения данных и метаинформации
- Сохранять исходный порядок точек для последующей диагностики ошибок

**Метаданные для валидации:**
- Степень полинома `n` (целое неотрицательное)
- Границы интервала `[a, b]` (вещественные числа, `a < b`)
- Параметр регуляризации `γ` (вещественное неотрицательное)

### Шаг 1.1.2: Проверка корректности интервала определения `[a, b]`

**Алгоритм проверки:**
1. Убедиться, что `a` и `b` являются конечными числами (не `NaN`, не `±Inf`)
   - Использовать `std::isfinite()` из `<cmath>`
2. Проверить строгое неравенство `a < b` с учётом машинной точности:
   - Допустимая погрешность: `ε_interval = 1e-12 * max(|a|, |b|, 1.0)`
   - Условие: `b - a > ε_interval`
3. При нарушении условий сформировать диагностическое сообщение с указанием:
   - Типа ошибки (некорректные границы, вырожденный интервал)
   - Фактических значений `a` и `b`
   - Рекомендации по исправлению

### Шаг 1.1.3: Проверка принадлежности всех точек интервалу `[a, b]`

**Стратегия сравнения с погрешностью:**
- Определить относительную погрешность для сравнения: `ε_point = 1e-9 * (b - a)`
- Для каждой точки из всех трёх множеств выполнить:
  - Проверка нижней границы: `x >= a - ε_point`
  - Проверка верхней границы: `x <= b + ε_point`
  - При нарушении зафиксировать:
    * Тип множества (аппроксимирующее/отталкивающее/интерполяционное)
    * Индекс точки в исходном массиве
    * Фактическое значение координаты
    * Расстояние до ближайшей границы интервала

**Особый случай — точки на границе:**
- Точки, лежащие в пределах `ε_point` от границ, автоматически «притягиваются» к границе:
  - `x = a`, если `x < a + ε_point`
  - `x = b`, если `x > b - ε_point`
- Это необходимо для корректного вычисления регуляризационного интеграла `∫(F''(x))²dx`

### Шаг 1.1.4: Проверка непересечения множеств точек

**Проблема точного сравнения вещественных чисел:**
- Прямое сравнение `x_i == y_j` ненадёжно из-за ошибок округления
- Использовать адаптивный порог сравнения:
  ```
  ε_overlap = max(1e-12, 1e-9 * max(|x_i|, |y_j|, 1.0))
  ```

**Алгоритм обнаружения пересечений:**
1. Объединить все точки в единый временный массив с пометкой типа:
   - Каждый элемент: `(координата, тип_точки, исходный_индекс)`
2. Отсортировать массив по координате (алгоритм сортировки со сложностью O(N log N))
3. Пройти по отсортированному массиву и сравнить соседние элементы:
   - Если разность координат `< ε_overlap` И типы точек различны → конфликт
   - Зафиксировать все конфликтующие пары для формирования отчёта

**Критичность конфликтов:**
- Пересечение `x_i` и `z_e` — фатальная ошибка (противоречие: «притяжение» vs «точная интерполяция»)
- Пересечение `y_j` и `z_e` — фатальная ошибка (противоречие: «отталкивание» vs «точная интерполяция»)
- Пересечение `x_i` и `y_j` — предупреждение (конфликт целей, но теоретически разрешимо через баланс весов)

### Шаг 1.1.5: Валидация весовых коэффициентов

**Проверка аппроксимирующих весов `σ_i`:**
- Каждый вес должен быть строго положительным: `σ_i > ε_weight`
  - `ε_weight = 1e-15` (защита от деления на ноль в функционале)
- Дополнительная проверка на разумный диапазон:
  - Отношение `max(σ_i) / min(σ_i) < 1e12` (избегание численной неустойчивости)
  - При нарушении рекомендовать нормализацию весов

**Проверка отталкивающих весов `B_j`:**
- Строгая положительность: `B_j > ε_weight`
- Предупреждение при экстремальных значениях:
  - `B_j > 1e8` может привести к «жёсткому» барьеру и численным трудностям
  - `B_j < 1e-6` делает отталкивание практически неэффективным

**Проверка параметра регуляризации `γ`:**
- Условие: `γ >= 0`
- Специальные случаи:
  - `γ = 0`: допустимо, но предупредить о риске осцилляций (феномен Рунге для полиномов высокой степени)
  - `γ > 1e6`: предупредить о чрезмерном сглаживании и потере адекватности аппроксимации

### Шаг 1.1.6: Проверка соотношения между степенью полинома и интерполяционными узлами

**Математическое ограничение:**
- Полином степени `n` имеет `n + 1` свободных коэффициентов
- Каждый интерполяционный узел накладывает одно линейное ограничение
- Условие разрешимости: `m ≤ n + 1`

**Дополнительные проверки:**
- Если `m == n + 1`: полином полностью определяется интерполяцией, аппроксимирующий и отталкивающий критерии становятся неэффективными — выдать предупреждение
- Если `m > n + 1`: система ограничений переопределена — фатальная ошибка
- Рекомендация при `m` близком к `n + 1`: увеличить степень полинома или уменьшить число узлов интерполяции

### Шаг 1.1.7: Формирование отчёта о валидации

**Структура отчёта:**
1. Сводная статистика:
   - Количество точек каждого типа
   - Диапазон весов для каждого множества
   - Степень полинома и число свободных параметров после учёта ограничений

2. Список критических ошибок (блокирующих выполнение):
   - Каждая ошибка с указанием типа, местоположения в данных, рекомендацией по исправлению

3. Список предупреждений (не блокирующих, но требующих внимания):
   - Потенциальные источники численной неустойчивости
   - Конфликты в постановке задачи
   - Рекомендации по настройке параметров

4. Рекомендации по коррекции:
   - Для каждой ошибки/предупреждения — конкретное действие (например: «Увеличьте степень полинома до 7» или «Удалите точку отталкивания с индексом 3»)

**Стратегия обработки результатов:**
- При наличии хотя бы одной критической ошибки — прервать выполнение алгоритма
- При наличии только предупреждений — продолжить с логированием предупреждений в консоль/файл
- Предусмотреть режим «строгой валидации» (любое предупреждение = ошибка) для отладки

### Шаг 1.1.8: Обработка крайних случаев

**Особые ситуации, требующие дополнительной проверки:**
- Пустые множества точек:
  - Пустое множество аппроксимирующих точек допустимо только при наличии интерполяционных узлов
  - Пустое множество отталкивающих точек — нормальная ситуация (классическая регуляризованная интерполяция)
- Вырожденные конфигурации:
  - Все точки одного типа сосредоточены в узком подынтервале (менее 1% от `[a, b]`)
  - Равномерное чередование точек притяжения и отталкивания с минимальным расстоянием
- Численные аномалии:
  - Веса, близкие к пределам представления `double` (`< 1e-300` или `> 1e300`)
  - Координаты точек, близкие к границам машинной точности

Этот план обеспечивает комплексную валидацию входных данных с учётом численных особенностей вещественной арифметики, предотвращает распространение ошибок на последующие этапы и предоставляет пользователю исчерпывающую диагностику для коррекции некорректных входных данных.