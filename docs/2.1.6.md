## Подшаг 2.1.6: Верификация корректности параметризации — подробный план реализации на C++

### Шаг 2.1.6.1: Формализация критериев корректности параметризации

**Три фундаментальных свойства корректной параметризации:**

1. **Точность интерполяции (обязательное свойство):**
   - Для всех узлов `z_e`: `|F(z_e) - f(z_e)| < ε_interp`
   - Порог точности: `ε_interp = 1e-10 · max(1.0, |f(z_e)|)`
   - Физический смысл: параметризация должна автоматически удовлетворять всем интерполяционным ограничениям

2. **Полнота пространства решений (обязательное свойство):**
   - Размерность подпространства коррекций должна равняться `n_free = n - m + 1`
   - Базисные функции `{φ_k(x)·W(x)}` должны быть линейно независимы
   - Физический смысл: параметризация должна охватывать всё подпространство решений, удовлетворяющих ограничениям

3. **Численная устойчивость (рекомендуемое свойство):**
   - Число обусловленности матрицы базиса `cond(G) < 1e10`
   - Отсутствие катастрофической потери точности при вычислениях
   - Физический смысл: параметризация должна быть пригодна для численной оптимизации

### Шаг 2.1.6.2: Алгоритм тестирования точности интерполяции

**Фаза 1: Прямая проверка в узлах интерполяции**

1. Для каждого узла `z_e` (в исходных координатах):
   - Вычислить значение через ленивую оценку:
     ```
     F_eval = P_int.evaluate(z_e) + Q.evaluate(z_e) * W.evaluate(z_e)
     ```
   - Вычислить отклонение: `δ_e = |F_eval - f(z_e)|`
   - Сохранить результат в структуре `InterpolationTestResult`:
     * `node_index = e`
     * `coordinate = z_e`
     * `target_value = f(z_e)`
     * `computed_value = F_eval`
     * `absolute_error = δ_e`
     * `relative_error = δ_e / max(1.0, |f(z_e)|)`

2. Критерий прохождения:
   - Все узлы должны удовлетворять: `δ_e < ε_interp`
   - Дополнительный критерий для узлов с малыми значениями (`|f(z_e)| < 1e-8`):
     * Требовать абсолютную ошибку `< 1e-12` вместо относительной

**Фаза 2: Диагностика источников ошибок при провале теста**

1. Если `|W(z_e)| > ε_w = 1e-12`:
   - Диагноз: ошибка в построении весового множителя
   - Причины:
     * Неправильная нормализация координат
     * Ошибка в алгоритме построения корней
     * Потеря точности при преобразовании координат
   - Стратегия коррекции:
     * Перестроить `W(x)` с использованием арифметики `long double`
     * Проверить корректность преобразования нормализованных ↔ исходных координат

2. Если `|P_int(z_e) - f(z_e)| > ε_interp`:
   - Диагноз: ошибка в построении базисного полинома
   - Причины:
     * Некорректные барицентрические веса
     * Ошибка в обработке совпадающих узлов
     * Потеря точности при вычислении весов
   - Стратегия коррекции:
     * Пересчитать веса через логарифмический подход
     * Для `m ≤ 5` переключиться на прямую форму Лагранжа для верификации

3. Если обе компоненты точны, но сумма неточна:
   - Диагноз: катастрофическая компенсация ошибок при сложении
   - Стратегия коррекции:
     * Применить компенсированную арифметику (алгоритм Кахана) для сложения
     * Использовать `long double` для критических вычислений

**Фаза 3: Расширенная проверка в окрестности узлов**

1. Для каждого узла `z_e` сгенерировать 5 контрольных точек в окрестности:
   - `x_test = z_e + k·δ`, где `k ∈ {-2, -1, 0, +1, +2}`, `δ = 1e-6·(b - a)`
2. Проверить непрерывность поведения функции:
   - Значения `F(x_test)` должны плавно стремиться к `f(z_e)` при `x_test → z_e`
   - Отсутствие осцилляций или разрывов в окрестности узла
3. При обнаружении аномалий:
   - Диагностировать как признак кратных корней или близких узлов
   - Рекомендовать объединение близких узлов или переход к сплайнам

### Шаг 2.1.6.3: Алгоритм тестирования полноты пространства решений

**Фаза 1: Построение матрицы базиса**

1. Сгенерировать `n_free` контрольных точек на интервале `[a, b]`:
   - Использовать узлы Чебышёва для минимизации числа обусловленности:
     ```
     x_k = (a + b)/2 + (b - a)/2 · cos(π·(2k - 1)/(2·n_free)), k = 1..n_free
     ```
   - Альтернатива при `n_free ≤ 5`: равномерная сетка для простоты диагностики

2. Построить матрицу базиса `G` размером `n_free × n_free`:
   - Элемент `G[i][k] = φ_k(x_i) · W(x_i)`, где:
     * `φ_k(x)` — k-я базисная функция корректирующего полинома (`x^k` или `T_k(t)`)
     * `W(x_i)` — значение весового множителя в точке `x_i`

3. Вычислить сингулярное разложение (SVD) матрицы `G`:
   - Получить сингулярные значения `σ_1 ≥ σ_2 ≥ ... ≥ σ_{n_free} ≥ 0`
   - Вычислить число обусловленности: `cond(G) = σ_1 / σ_{n_free}`

**Фаза 2: Анализ линейной независимости**

1. Критерий полного ранга:
   - Все сингулярные значения должны удовлетворять: `σ_k > ε_svd · σ_1`
   - Порог: `ε_svd = max(1e-12, 1e-8 · n_free)` (адаптивный к размерности)
   - Если хотя бы одно `σ_k ≤ ε_svd · σ_1` — матрица вырождена, ранг < `n_free`

2. Критерий численной устойчивости:
   - Приемлемое число обусловленности: `cond(G) < 1e8`
   - Предупреждение при `1e8 ≤ cond(G) < 1e12`
   - Критическая неустойчивость при `cond(G) ≥ 1e12`

3. Диагностика причин вырождения:
   - Если вырождение связано с первыми базисными функциями (`σ_0`, `σ_1` малы):
     * Причина: плохой выбор базиса (мономиальный базис при высоких степенях)
     * Решение: переключиться на базис Чебышёва
   - Если вырождение связано с последними базисными функциями (`σ_{n_free-1}`, `σ_{n_free-2}` малы):
     * Причина: близость корней весового множителя или вырожденная геометрия узлов
     * Решение: объединить близкие узлы или уменьшить степень полинома

**Фаза 3: Тест на достижимость произвольных коррекций**

1. Сгенерировать случайный целевой вектор коррекций `Δ_target[0..n_free-1]`:
   - Компоненты — случайные числа из равномерного распределения `[-1, 1]`

2. Решить линейную систему `G · q = Δ_target`:
   - Использовать метод наименьших квадратов через SVD для устойчивости
   - Получить коэффициенты `q_solution`

3. Проверить качество решения:
   - Вычислить невязку: `residual = ||G · q_solution - Δ_target||_2`
   - Критерий успеха: `residual < 1e-8 · ||Δ_target||_2`
   - Повторить тест 10 раз с разными случайными векторами

4. При систематическом провале теста:
   - Диагностировать как признак неполного пространства решений
   - Проверить корректность вычисления базисных функций и их производных

### Шаг 2.1.6.4: Алгоритм тестирования численной устойчивости

**Фаза 1: Тест на устойчивость к малым возмущениям**

1. Сгенерировать возмущённый набор узлов интерполяции:
   - `z_e_perturbed = z_e + ξ_e · ε_pert · (b - a)`
   - `ξ_e` — случайное число из `[-1, 1]`, `ε_pert = 1e-8`

2. Построить возмущённую параметризацию с теми же коэффициентами `q_k`

3. Оценить изменение функции в контрольной точке `x_test = (a + b)/2`:
   - `ΔF = |F_perturbed(x_test) - F_original(x_test)|`
   - Относительное изменение: `δ_rel = ΔF / max(1.0, |F_original(x_test)|)`

4. Критерий устойчивости:
   - Приемлемо: `δ_rel < 10 · ε_pert` (линейная зависимость от возмущения)
   - Предупреждение: `10 · ε_pert ≤ δ_rel < 100 · ε_pert`
   - Критическая неустойчивость: `δ_rel ≥ 100 · ε_pert`

**Фаза 2: Тест на масштабируемость вычислений**

1. Оценить порядок величины ключевых компонентов:
   - `max|P_int(x)|` на `[a, b]`
   - `max|W(x)|` на `[a, b]`
   - `max|Q(x)|` при `||q||_∞ = 1`

2. Проверить баланс масштабов:
   - Если отношение `max|P_int| / max|Q·W| > 1e6` или `< 1e-6`:
     * Диагноз: плохой масштаб параметризации
     * Риск: потеря точности при сложении компонентов разного масштаба
   - Стратегия коррекции:
     * Применить нормализацию коэффициентов `q_k` с сохранением пространства решений
     * Использовать компенсированную арифметику для критических операций

**Фаза 3: Тест на устойчивость градиента**

1. Вычислить градиент функционала в начальной точке (нулевые коэффициенты `q_k = 0`)

2. Оценить норму градиента по каждой компоненте:
   - `||∇_k J||` для `k = 0..n_free-1`

3. Проверить баланс компонент градиента:
   - Если `max_k ||∇_k J|| / min_k ||∇_k J|| > 1e6`:
     * Диагноз: плохая обусловленность задачи оптимизации
     * Риск: медленная сходимость или застревание оптимизатора
   - Стратегия коррекции:
     * Применить предобуславливание (масштабирование параметров)
     * Переключиться на ортогональный базис Чебышёва

### Шаг 2.1.6.5: Структура данных для хранения результатов верификации

**Основная структура `ParameterizationVerification`:**
```cpp
struct ParameterizationVerification {
    // Общий статус верификации
    VerificationStatus overall_status;  // PASSED, WARNING, FAILED
    
    // Результаты теста интерполяции
    struct InterpolationTest {
        bool passed;
        int failed_nodes_count;
        double max_absolute_error;
        double max_relative_error;
        std::vector<NodeError> node_errors;  // детали по каждому узлу
    } interpolation_test;
    
    // Результаты теста полноты пространства
    struct CompletenessTest {
        bool passed;
        int actual_rank;
        int expected_rank;
        double condition_number;
        std::vector<double> singular_values;
    } completeness_test;
    
    // Результаты теста устойчивости
    struct StabilityTest {
        bool passed;
        double perturbation_sensitivity;
        double scale_balance_ratio;
        double gradient_condition_number;
    } stability_test;
    
    // Диагностические рекомендации
    std::vector<std::string> warnings;
    std::vector<std::string> errors;
    std::vector<Recommendation> recommendations;
};
```

**Вспомогательные структуры:**
- `NodeError`: хранит детали ошибки для конкретного узла (координата, ожидаемое/фактическое значение, диагностика источника)
- `Recommendation`: содержит тип рекомендации (ИЗМЕНИТЬ_БАЗИС, ОБЪЕДИНИТЬ_УЗЛЫ, СНИЗИТЬ_СТЕПЕНЬ) и аргументацию

### Шаг 2.1.6.6: Стратегии коррекции при неудачной верификации

**Стратегия А: Автоматическая коррекция параметризации**

1. При выявленной плохой обусловленности мономиального базиса:
   - Автоматически переключиться на базис Чебышёва
   - Пересчитать все кэши и матрицы с новым базисом
   - Повторить верификацию

2. При обнаружении близких узлов интерполяции:
   - Применить алгоритм кластеризации узлов с порогом `ε_cluster = 1e-4·(b - a)`
   - Объединить узлы в кластере с усреднением значений `f(z_e)`
   - Уменьшить эффективное число узлов `m_eff`
   - Перестроить параметризацию с новыми узлами
   - Повторить верификацию

**Стратегия Б: Адаптивное снижение требований**

1. При невозможности достичь `ε_interp = 1e-10`:
   - Попробовать ослабить критерий до `ε_interp = 1e-8`
   - Если проходит — выдать предупреждение, но продолжить алгоритм
   - Если не проходит — фатальная ошибка

2. При высоком числе обусловленности (`cond(G) > 1e10`):
   - Применить регуляризацию при решении линейных систем:
     * Добавить диагональный член `λ·I` к матрице `GᵀG`
     * Начальное значение `λ = 1e-6 · σ_1²`
   - Выдать предупреждение о потенциальной потере точности

**Стратегия В: Откат к альтернативной параметризации**

1. При полном провале верификации:
   - Переключиться на метод множителей Лагранжа вместо параметризации «базис + коррекция»
   - Построить расширенный функционал:
     ```
     J_extended = J(F) + Σ λ_e · (F(z_e) - f(z_e))
     ```
   - Оптимизировать по совокупности переменных `(коэффициенты_F, λ_e)`
   - Преимущество: не требует специальной параметризации, но увеличивает размерность задачи

### Шаг 2.1.6.7: Генерация диагностического отчёта

**Структура отчёта верификации:**

1. **Сводная секция:**
   ```
   Верификация параметризации: [ПРОЙДЕНА/ПРЕДУПРЕЖДЕНИЯ/ПРОВАЛЕНА]
   Степень полинома: n = 12
   Число узлов интерполяции: m = 5
   Свободных параметров: n_free = 8
   ```

2. **Детали теста интерполяции:**
   ```
   Тест интерполяции:
   • Проверено узлов: 5/5
   • Макс. абсолютная ошибка: 3.2e-13
   • Макс. относительная ошибка: 1.7e-14
   • Статус: ПРОЙДЕН
   ```

3. **Детали теста полноты:**
   ```
   Тест полноты пространства:
   • Ожидаемый ранг: 8
   • Фактический ранг: 8
   • Число обусловленности: 4.7e+03
   • Мин. сингулярное значение: 2.1e-04 (отн. к макс.: 4.5e-08)
   • Статус: ПРОЙДЕН (устойчиво)
   ```

4. **Детали теста устойчивости:**
   ```
   Тест устойчивости:
   • Чувствительность к возмущениям: 8.3e-09 (при ε_pert=1e-08)
   • Баланс масштабов компонентов: 1.2e+00
   • Число обусловленности градиента: 2.1e+02
   • Статус: ПРОЙДЕН
   ```

5. **Рекомендации:**
   ```
   Рекомендации:
   • [ИНФО] Использован базис Чебышёва для улучшения устойчивости
   • [ПРЕДУПРЕЖДЕНИЕ] Минимальное расстояние между узлами = 0.012·(b-a)
     Рассмотрите объединение узлов 3 и 4 при проблемах сходимости
   • [РЕКОМЕНДАЦИЯ] Для ускорения оптимизации увеличьте γ до 0.1
   ```

**Форматы вывода отчёта:**
- Текстовый формат для консоли (краткий/подробный режим)
- JSON для программной обработки последующими этапами
- HTML для визуализации в интерактивных инструментах

### Шаг 2.1.6.8: Интеграция верификации в основной алгоритм

**Точка интеграции:**
- Верификация выполняется непосредственно после построения параметризации (подшаги 2.1.1–2.1.5)
- Перед передачей параметризации оптимизатору

**Логика принятия решений:**

1. Если `overall_status == PASSED`:
   - Продолжить выполнение алгоритма
   - Передать параметризацию оптимизатору

2. Если `overall_status == WARNING`:
   - Залогировать все предупреждения
   - Продолжить выполнение с флагом `has_warnings = true`
   - При последующих проблемах сходимости оптимизатора — вернуться к этапу верификации

3. Если `overall_status == FAILED`:
   - Применить стратегию автоматической коррекции (шаг 2.1.6.6)
   - Если коррекция успешна — повторить верификацию
   - Если коррекция неуспешна — прервать алгоритм с детальным отчётом об ошибках
   - Предложить пользователю альтернативные стратегии (снижение степени, объединение узлов, смена базиса)

**Механизм отладки:**
- Режим подробной верификации (`verbose_verification = true`):
  * Вывод промежуточных результатов каждого теста
  * Сохранение диагностических данных в файлы для последующего анализа
  * Визуализация поведения функции в окрестности проблемных узлов

Этот план обеспечивает всестороннюю верификацию корректности параметризации с автоматической диагностикой источников ошибок, адаптивными стратегиями коррекции и подробной отчётностью для принятия обоснованных решений о продолжении или модификации алгоритма. Верификация служит критическим барьером качества, предотвращающим распространение численных ошибок на последующие этапы оптимизации.