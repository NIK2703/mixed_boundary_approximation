## Подшаг 5.1: Защита от особенностей отталкивающего члена — подробный план реализации на C++

### Шаг 5.1.1: Математическая модель барьерной особенности и её классификация

**Характеристика особенности:**
- Отталкивающий член имеет вид `B_j / |y_j^* - F(y_j)|^p`, где `p = 2` (квадратичный барьер) или `p = 1` (логарифмический)
- При `|y_j^* - F(y_j)| → 0` функционал и его градиент стремятся к бесконечности со скоростью `O(1/δ^p)` и `O(1/δ^{p+1})` соответственно
- Это создаёт численные проблемы:
  * Переполнение при вычислении (`> 1e308` для `double`)
  * Взрывной рост градиента → неустойчивость шага оптимизатора
  * Осцилляции вблизи барьера из-за чрезмерной коррекции

**Классификация зон приближения к барьеру:**
```
Зона 1: КРИТИЧЕСКАЯ      |δ| ≤ ε_critical      (1e-8)    → требуется немедленная защита
Зона 2: ПРЕДУПРЕДИТЕЛЬНАЯ ε_critical < |δ| ≤ ε_warning (1e-4) → требуется осторожная адаптация
Зона 3: БЕЗОПАСНАЯ      |δ| > ε_warning                → стандартная обработка
```
где `δ = y_j^* - F(y_j)` — алгебраическое расстояние до запрещённого значения.

### Шаг 5.1.2: Реализация многоуровневой системы порогов безопасности

**Определение адаптивных порогов:**
1. **Базовые пороги (статические):**
   - `ε_critical_base = 1e-8` — абсолютный минимум для предотвращения деления на машинный ноль
   - `ε_warning_base = 1e-4` — порог начала осторожного режима

2. **Масштабирование порогов под задачу:**
   - Оценить характерный масштаб значений функции:
     ```
     scale_y = max(1.0, 0.1 * (max|f(x_i)| + max|y_j^*|))
     ```
   - Адаптивные пороги:
     ```
     ε_critical = max(ε_critical_base, 1e-10 * scale_y)
     ε_warning  = max(ε_warning_base,  1e-6  * scale_y)
     ```

3. **Динамическая коррекция в процессе оптимизации:**
   - Отслеживать минимальное расстояние до барьеров за последние 10 итераций: `δ_min_history`
   - Если `δ_min_history` стабильно уменьшается:
     ```
     ε_critical_effective = max(ε_critical, 2.0 * δ_min_history)
     ε_warning_effective  = max(ε_warning,  10.0 * δ_min_history)
     ```
   - Это создаёт «буфер безопасности» перед приближением к критической зоне

**Хранение состояния барьеров:**
- Для каждой отталкивающей точки хранить структуру:
  ```cpp
  struct BarrierState {
      double current_distance;    // текущее |δ|
      double min_distance_10it;   // минимум за 10 итераций
      ZoneClassification zone;    // CRITICAL/WARNING/SAFE
      bool approaching;           // признак сближения (δ уменьшается)
      int iterations_in_zone;     // итераций в текущей зоне подряд
  };
  ```

### Шаг 5.1.3: Сглаживающие функции для критической зоны

**Принцип сглаживания:**
- Заменить сингулярную функцию `1/|δ|^p` на гладкую аппроксимацию, совпадающую с исходной вне критической зоны и ограниченную внутри неё

**Вариант A: Квадратично-сглаженный барьер (рекомендуемый):**
```
Для |δ| ≤ ε_critical:
    term = B_j / (ε_critical² + k·(ε_critical - |δ|)²)
где k = 5.0 — коэффициент сглаживания

Для ε_critical < |δ| ≤ ε_warning:
    α = (|δ| - ε_critical) / (ε_warning - ε_critical)  // интерполяция 0→1
    term = B_j · [α/|δ|² + (1-α)/(ε_critical² + k·ε_critical²)]

Для |δ| > ε_warning:
    term = B_j / |δ|²  // стандартная формула
```
- Преимущества: непрерывная первая производная, плавный переход, ограниченность

**Вариант B: Логарифмический барьер (альтернативный):**
```
term = -B_j · log(max(|δ|, ε_critical))
```
- Преимущества: естественная ограниченность градиента (`~1/ε_critical` вместо `~1/ε_critical³`)
- Недостатки: менее интуитивная интерпретация веса `B_j`, медленнее отталкивание в безопасной зоне

**Вариант C: Гибридный барьер с динамическим переключением:**
- Использовать квадратичный барьер в безопасной зоне для сильного отталкивания
- Автоматически переключаться на логарифмический при входе в предупредительную зону:
  ```
  если зона == WARNING ИЛИ зона == CRITICAL:
      использовать логарифмический барьер
  иначе:
      использовать квадратичный барьер
  ```
- Обеспечивает баланс между эффективностью отталкивания и численной устойчивостью

### Шаг 5.1.4: Защита градиента в критической зоне

**Проблема градиента:**
- Градиент отталкивающего члена содержит множитель `~1/|δ|³`, что при `|δ| = 1e-8` даёт коэффициент `1e24`
- Даже при малых базисных функциях это вызывает переполнение или чрезмерные шаги оптимизатора

**Стратегия ограничения градиента:**
1. **Компонентное ограничение:**
   - Для каждой компоненты градиента `g_k` вычислить «необработанное» значение
   - Ограничить по абсолютной величине:
     ```
     g_k_clipped = sign(g_k) · min(|g_k|, G_max)
     где G_max = 1e8 / n_free  // зависит от размерности задачи
     ```

2. **Норма-ограничение с сохранением направления:**
   - Вычислить евклидову норму вектора градиента отталкивания: `||g_repulse||`
   - Если `||g_repulse|| > G_max_total`:
     ```
     g_repulse ← g_repulse · (G_max_total / ||g_repulse||)
     где G_max_total = 1e6  // глобальный лимит нормы
     ```
   - Сохраняет направление градиента, ограничивая только масштаб

3. **Адаптивное ограничение на основе истории:**
   - Хранить максимальную норму градиента за последние 50 итераций: `G_max_history`
   - Установить динамический лимит:
     ```
     G_max_adaptive = max(1e4, 10.0 * G_max_history)
     ```
   - При превышении лимита применить смягчающий коэффициент:
     ```
     α_damp = G_max_adaptive / ||g_repulse||
     g_repulse ← g_repulse · min(1.0, α_damp)
     ```

### Шаг 5.1.5: Интеграция с оптимизатором: динамическая адаптация шага

**Механизм обратной связи «барьер → оптимизатор»:**
1. **Вычисление метрики опасности:**
   - Для текущей итерации вычислить:
     ```
     danger_score = Σ_j [ B_j / max(|δ_j|, ε_critical) ] / Σ_j B_j
     ```
   - Нормализованный показатель близости к барьерам (0 = безопасно, 1 = критично)

2. **Коррекция параметров линейного поиска:**
   - При `danger_score > 0.5` (предупредительная зона):
     ```
     α_initial ← 0.5 · α_initial          // уменьшить начальный шаг
     max_ls_trials ← 2 · max_ls_trials    // увеличить попытки линейного поиска
     ```
   - При `danger_score > 0.9` (критическая зона):
     ```
     α_initial ← 0.1 · α_initial
     применить «откат» на предыдущую безопасную итерацию
     ```

3. **Реализация через колбэк-интерфейс:**
   - Создать интерфейс `BarrierSafetyMonitor` с методом:
     ```cpp
     double get_step_damping_factor() const;
     ```
   - Оптимизатор вызывает этот метод перед каждым линейным поиском
   - Фактор демпфирования `∈ [0.01, 1.0]` умножается на предлагаемый шаг

### Шаг 5.1.6: Обнаружение и восстановление после «барьерного коллапса»

**Диагностика коллапса:**
- **Признак 1:** Резкий скачок функционала: `J_k / J_{k-1} > 100`
- **Признак 2:** Появление `NaN/Inf` в значении функционала или градиента
- **Признак 3:** Расстояние до барьера `|δ_j| < 0.1 · ε_critical` для любой точки

**Алгоритм восстановления:**
1. **Немедленная реакция:**
   - Прервать текущую итерацию оптимизатора
   - Вернуться к последней «безопасной» итерации (сохранённой в истории)
   - Зафиксировать событие в логе с указанием точки барьера и расстояния

2. **Коррекция траектории:**
   - Вычислить направление «от барьера»:
     ```
     escape_direction = Σ_{j: |δ_j| < ε_warning} sign(δ_j) · [φ_k(y_j)·W(y_j)]
     ```
   - Выполнить короткий шаг в этом направлении:
     ```
     α_escape = 0.01 · min(ε_warning, ||q_current||)
     q_corrected = q_safe + α_escape · escape_direction / ||escape_direction||
     ```

3. **Адаптация параметров для предотвращения повторения:**
   - Временно уменьшить веса опасных барьеров:
     ```
     для всех j где |δ_j| < ε_warning:
         B_j_temp = 0.1 · B_j_original
     ```
   - Увеличить параметр регуляризации для сглаживания траектории:
     ```
     γ_temp = 2.0 · γ_original
     ```
   - После выхода из опасной зоны постепенно восстановить исходные параметры («отжиг»)

### Шаг 5.1.7: Превентивная защита на этапе инициализации

**Проверка начального приближения:**
- После инициализации параметров (шаг 4.2) выполнить:
  ```
  для каждой отталкивающей точки j:
      δ_j = y_j^* - F_initial(y_j)
      если |δ_j| < 5 · ε_critical:
          применить превентивную коррекцию (шаг 4.2.3)
  ```

**Генерация «барьерно-безопасного» начального приближения:**
- Модифицировать МНК-инициализацию добавлением штрафа за близость к барьерам:
  ```
  J_init = J_mnk + λ_barrier · Σ_j exp(-|δ_j| / ε_warning)
  где λ_barrier = 10 · avg(σ_i)
  ```
- Минимизировать `J_init` градиентным спуском (5–10 итераций) перед основной оптимизацией
- Гарантирует стартовую точку вне критической зоны

### Шаг 5.1.8: Диагностическая система мониторинга барьеров

**Реестр барьерных событий:**
- Хранить хронологию для каждой отталкивающей точки:
  ```cpp
  struct BarrierEvent {
      int iteration;
      double distance;
      ZoneClassification zone;
      double functional_value;
      bool caused_step_rejection;  // шаг оптимизатора был отклонён из-за барьера
  };
  ```

**Генерация предупреждений:**
- При первом входе в критическую зону:
  ```
  ПРЕДУПРЕЖДЕНИЕ: Приближение к барьеру в точке y=2.5 (итерация 47)
  Текущее расстояние: 8.3e-9 < 1e-8 (критический порог)
  Применена барьерная защита: сглаживание + ограничение градиента
  ```
- При повторяющемся коллапсе (> 3 раз за 100 итераций):
  ```
  КРИТИЧЕСКОЕ ПРЕДУПРЕЖДЕНИЕ: Устойчивые проблемы с барьером в точке y=2.5
  Рекомендации:
    • Уменьшить вес B_j с 1000 до 100
    • Увеличить минимальное расстояние ε_critical до 1e-6
    • Рассмотреть альтернативную постановку задачи (барьер может быть избыточно строгим)
  ```

**Визуализация для отладки (опционально):**
- Сохранять траекторию расстояний `|δ_j(iteration)|` для всех барьеров
- Генерировать график с зонами безопасности для анализа поведения оптимизатора
- Выделять итерации, где применялась барьерная защита

Этот план обеспечивает многоуровневую, адаптивную защиту от численных особенностей отталкивающего члена, сочетающую проактивную превенцию, реактивное восстановление и прозрачную диагностику. Подход гарантирует устойчивую работу оптимизатора даже вблизи сингулярных барьеров, сохраняя при этом физический смысл отталкивающего критерия через плавные сглаживающие функции.