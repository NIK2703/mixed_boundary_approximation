## Подшаг 2.1: Параметризация полинома с учётом интерполяционных ограничений — подробный план реализации на C++

### Шаг 2.1.1: Математическая основа параметризации «базис + коррекция»

**Концепция разделения пространства решений:**
- Пространство всех полиномов степени `n` имеет размерность `n + 1`
- Каждое интерполяционное условие `F(z_e) = f(z_e)` накладывает одно линейное ограничение
- После учёта `m` ограничений остаётся `n + 1 - m` свободных степеней свободы
- Цель параметризации: построить базис в подпространстве полиномов, удовлетворяющих всем ограничениям

**Фундаментальное тождество:**
```
F(x) = P_int(x) + Q(x) · W(x)
где:
  P_int(x) — базисный полином, точно интерполирующий все узлы (z_e, f(z_e))
  W(x) = Π_{e=1..m} (x - z_e) — весовой множитель (произведение линейных множителей)
  Q(x) — корректирующий полином степени (n - m)
```
- При подстановке `x = z_e`: `W(z_e) = 0`, следовательно `F(z_e) = P_int(z_e) = f(z_e)`
- Все интерполяционные условия выполняются автоматически независимо от выбора `Q(x)`

### Шаг 2.1.2: Построение базисного интерполяционного полинома `P_int(x)`

**Выбор алгоритма интерполяции:**
- **Метод Лагранжа (прямой):**
  * Формула: `P_int(x) = Σ_{e=1..m} f(z_e) · L_e(x)`
  * Базисные полиномы: `L_e(x) = Π_{k≠e} (x - z_k) / (z_e - z_k)`
  * Преимущество: простота реализации
  * Недостаток: численная неустойчивость при `m > 15` из-за накопления ошибок округления
  
- **Барицентрическая интерполяция (рекомендуемая):**
  * Предварительный расчёт весов: `w_e = 1 / Π_{k≠e} (z_e - z_k)`
  * Оценка полинома: `P_int(x) = [Σ w_e · f(z_e) / (x - z_e)] / [Σ w_e / (x - z_e)]`
  * Преимущество: высокая численная устойчивость, эффективность повторных вычислений
  * Требует обработки особого случая `x == z_e` (возврат `f(z_e)` напрямую)

**Алгоритм построения:**
1. Валидация узлов: проверка уникальности `z_e` с точностью `ε = 1e-12·(b-a)`
2. Сортировка узлов по возрастанию для улучшения численной устойчивости
3. Вычисление весов барицентрической формулы в логарифмическом масштабе:
   * Для каждого `e`: `log|w_e| = -Σ_{k≠e} log|z_e - z_k|`
   * Отдельное хранение знака веса для избежания потери точности
4. Кэширование весов `w_e` и значений `f(z_e)` в структуре `InterpolationBasis`

**Численная защита:**
- При близких узлах (`|z_e - z_k| < ε_close`) объединять узлы с усреднением значений `f(z)`
- Контроль переполнения/потери точности при вычислении произведений через логарифмирование
- Для `m > 30` рекомендовать переход к сплайн-интерполяции вместо глобального полинома

### Шаг 2.1.3: Построение весового множителя `W(x) = Π(x - z_e)`

**Представление полинома:**
- `W(x)` — монический полином степени `m` с корнями в точках `z_e`
- Коэффициенты вычисляются инкрементальным умножением:
  ```
  W(x) = 1
  для каждого узла z_e:
      W(x) = W(x) · (x - z_e)
  ```
- Представление в виде массива коэффициентов `[w_m, w_{m-1}, ..., w_0]`, где `w_m = 1`

**Оптимизация вычислений:**
- Использовать схему Горнера для вычисления значения `W(x)`:
  ```
  result = 1.0
  для k от m-1 до 0:
      result = result * x + w_k
  ```
- Предварительное вычисление и кэширование значений `W(x)` в точках `{x_i}` и `{y_j}` для ускорения оценки функционала
- Для производных: аналитическое вычисление `W'(x)` и `W''(x)` через рекуррентные соотношения

**Численная стабилизация:**
- При большом разбросе узлов (`max(z_e) / min(z_e) > 1e6`) применять нормализацию:
  * Сдвиг: `z_e' = z_e - z_mean`
  * Масштабирование: `z_e'' = z_e' / scale`, где `scale = (b - a)`
  * После оптимизации выполнить обратное преобразование коэффициентов

### Шаг 2.1.4: Параметризация корректирующего полинома `Q(x)`

**Структура пространства свободных параметров:**
- Степень `Q(x)`: `deg_Q = n - m` (гарантированно неотрицательна благодаря валидации шага 1.1)
- Количество свободных коэффициентов: `n_free = deg_Q + 1 = n - m + 1`
- Представление: массив `q_coeffs[0..deg_Q]`, где `q_coeffs[k]` соответствует коэффициенту при `x^k`

**Базис для корректирующего полинома:**
- **Стандартный мономиальный базис** (простота):
  ```
  Q(x) = q_0 + q_1·x + q_2·x² + ... + q_{deg_Q}·x^{deg_Q}
  ```
- **Ортогональный базис Чебышёва** (рекомендуется для устойчивости):
  * Преобразование интервала `[a, b]` в `[-1, 1]`: `t = 2·(x - a)/(b - a) - 1`
  * Представление: `Q(x) = Σ_{k=0..deg_Q} q_k · T_k(t)`, где `T_k` — полиномы Чебышёва
  * Преимущество: уменьшение проблемы неустойчивости при высоких степенях

**Инициализация коэффициентов:**
- Нулевая инициализация (`q_k = 0`) даёт начальное приближение `F(x) = P_int(x)`
- Альтернатива: решение взвешенного МНК только по аппроксимирующим точкам `{x_i}` с последующим проецированием на подпространство `Q(x)·W(x)`

### Шаг 2.1.5: Сборка итогового полинома `F(x)`

**Алгебраическая сборка (для аналитических вычислений):**
1. Вычислить произведение `Q(x) · W(x)`:
   * Свёртка коэффициентов через дискретную свёртку (алгоритм сложности O(n·m))
   * Результат: полином степени `n` с коэффициентами `c_k`
2. Сложить с коэффициентами `P_int(x)`:
   * `a_k = p_k + c_k`, где `p_k` — коэффициенты базисного полинома
3. Получить итоговый массив коэффициентов `F_coeffs[0..n]`

**Ленивая оценка (для численных вычислений):**
- Не вычислять явно коэффициенты `F(x)`, а оценивать значение «на лету»:
  ```
  F(x) = evaluate_lagrange(x) + evaluate_Q(x) * evaluate_W(x)
  ```
- Преимущества:
  * Избегание численной неустойчивости при перемножении полиномов высокой степени
  * Эффективность при многократной оценке в одних и тех же точках (кэширование `W(x_i)`)
- Недостаток: невозможность прямого доступа к коэффициентам для аналитического интегрирования

**Гибридный подход (рекомендуемый):**
- Хранить три компонента отдельно: `P_int`, `Q`, `W`
- Для оценки функционала использовать ленивую оценку
- Для регуляризационного члена `∫(F''(x))²dx` вычислять аналитически через коэффициенты:
  * `F''(x) = P_int''(x) + Q''(x)·W(x) + 2·Q'(x)·W'(x) + Q(x)·W''(x)`
  * Интеграл раскладывается на сумму интегралов от произведений базисных полиномов
  * Предварительно вычислить матрицу «жёсткости» `K_{kl} = ∫ φ_k''(x) φ_l''(x) dx`

### Шаг 2.1.6: Верификация корректности параметризации

**Тест на выполнение интерполяционных условий:**
1. Для каждого узла `z_e` вычислить `F(z_e)` через ленивую оценку
2. Проверить отклонение: `|F(z_e) - f(z_e)| < ε_interp`, где `ε_interp = 1e-10·max(1, |f(z_e)|)`
3. При нарушении:
   * Проверить корректность вычисления `W(z_e)` (должно быть близко к нулю)
   * Проверить точность интерполяционного полинома `P_int(z_e)`
   * При необходимости перейти к арифметике повышенной точности (long double)

**Тест на полноту пространства:**
- Сгенерировать случайные наборы коэффициентов `q_k`
- Убедиться, что получающиеся полиномы `F(x)` линейно независимы
- Проверить ранг матрицы значений в контрольных точках (должен быть `n - m + 1`)

### Шаг 2.1.7: Структуры данных для хранения параметризации

**Основная структура `ConstrainedPolynomial`:**
```cpp
struct ConstrainedPolynomial {
    // Базисная компонента
    InterpolationBasis basis;        // веса Лагранжа/барицентрические веса
    
    // Весовой множитель
    std::vector<double> W_coeffs;    // коэффициенты W(x), размер m+1
    std::vector<double> W_cache_x;   // закэшированные значения W(x_i)
    std::vector<double> W_cache_y;   // закэшированные значения W(y_j)
    
    // Корректирующая компонента
    int deg_Q;                       // степень Q(x) = n - m
    std::vector<double> q_coeffs;    // свободные параметры оптимизации
    
    // Метаданные
    int n;                           // итоговая степень F(x)
    int m;                           // число интерполяционных узлов
    double a, b;                     // границы интервала
};
```

**Вспомогательные структуры:**
- `InterpolationBasis`: хранит узлы `z_e`, значения `f(z_e)`, веса `w_e`, флаг использования барицентрической формы
- `PolynomialEvaluator`: инкапсулирует схему Горнера и кэширование для эффективной оценки

### Шаг 2.1.8: Обработка крайних случаев

**Случай `m = 0` (отсутствие интерполяционных узлов):**
- Упрощённая параметризация: `F(x) = Q(x)`, где `deg_Q = n`
- `W(x) = 1` (вырожденный случай)
- Базисный полином `P_int(x) = 0`

**Случай `m = n + 1` (полная интерполяция):**
- Корректирующий полином вырождается: `deg_Q = -1` → `Q(x) ≡ 0`
- Единственное решение: `F(x) = P_int(x)`
- Аппроксимирующий и отталкивающий критерии становятся неактивными — выдать предупреждение

**Случай кратных корней в `W(x)`:**
- Если пользователь задал близкие узлы (`|z_e - z_k| < ε`), объединить их с усреднением значений
- При необходимости ввести кратные корни: `W(x) = (x - z)^p`, что потребует модификации параметризации

### Шаг 2.1.9: Интеграция с последующими этапами оптимизации

**Интерфейс для оптимизатора:**
- Метод `evaluate(x)`: возвращает значение `F(x)` для произвольной точки
- Метод `gradient(x, output)`: вычисляет градиент функционала по коэффициентам `q_k` в точке `x`
  * Градиент по `q_k`: `∂F/∂q_k = φ_k(x) · W(x)`, где `φ_k` — базисная функция для `Q(x)`
- Метод `second_derivative(x)`: возвращает `F''(x)` для регуляризационного члена

**Подготовка к оптимизации:**
- Предварительное вычисление и кэширование:
  * Значений `W(x_i)` и `W(y_j)` для всех точек данных
  * Значений базисных функций `φ_k(x_i)`, `φ_k(y_j)` для градиента
  * Матрицы интегралов `∫ φ_k''(x) φ_l''(x) W(x)² dx` для регуляризации
- Сокращение вычислительной сложности оценки градиента с O(n·N) до O(N), где N — число точек данных

Этот план обеспечивает математически корректную параметризацию, автоматически удовлетворяющую всем интерполяционным ограничениям, при сохранении полной гибкости для оптимизации свободных параметров. Подход минимизирует размерность задачи оптимизации и исключает необходимость в методах условной оптимизации, что значительно упрощает численную реализацию и повышает устойчивость алгоритма.