## Подшаг 2.1.7: Структуры данных для хранения параметризации — подробный план реализации на C++

### Шаг 2.1.7.1: Архитектурные принципы проектирования структур данных

**Принцип разделения ответственности:**
- Каждая структура данных инкапсулирует один логический компонент параметризации
- Чёткое разделение между данными (коэффициенты, узлы) и поведением (методы вычисления)
- Минимизация связности между компонентами для упрощения модификации и тестирования

**Принцип оптимизации памяти:**
- Предпочтение `std::vector<double>` перед динамическими массивами для автоматического управления памятью
- Выравнивание данных для векторизации (аллокация с выравниванием 32/64 байта для AVX/AVX-512)
- Избегание избыточного копирования через семантику перемещения (move semantics)

**Принцип кэширования вычислений:**
- Предварительное вычисление и сохранение значений, используемых многократно (весовой множитель в точках данных)
- Разделение кэшей по типу использования: «горячие» данные (для оптимизации) и «холодные» (для диагностики)
- Стратегия инвалидации кэшей при изменении параметров

### Шаг 2.1.7.2: Структура для хранения узлов интерполяции и значений

**Структура `InterpolationNodeSet`:**
```cpp
// Назначение: хранение исходных данных об интерполяционных узлах
struct InterpolationNodeSet {
    // Основные данные
    std::vector<double> x_coords;      // Абсциссы узлов z_e в исходных координатах
    std::vector<double> y_values;      // Ординаты значений f(z_e)
    int count;                         // Эффективное число узлов (после объединения близких)
    
    // Нормализованные координаты (для численной устойчивости)
    std::vector<double> x_norm;        // z_e в интервале [-1, 1]
    double norm_center;                // Центр нормализации: (a + b) / 2
    double norm_scale;                 // Масштаб нормализации: (b - a) / 2
    
    // Метаданные качества данных
    double min_distance;               // Минимальное расстояние между узлами
    double value_range;                // Диапазон значений: max(f) - min(f)
    bool has_close_nodes;              // Флаг наличия близких узлов (< 1% от (b-a))
    
    // Статус валидации
    bool is_valid;                     // Корректность набора узлов
    std::string validation_error;      // Сообщение об ошибке при некорректности
    
    // Методы доступа (реализуются как свободные функции или методы-обёртки)
    // • size() → количество узлов
    // • get_original(int idx) → (x, y) в исходных координатах
    // • get_normalized(int idx) → (x_norm, y) в нормализованных координатах
};
```

**Особенности реализации:**
- Конструктор принимает исходные данные и автоматически выполняет нормализацию
- Метод `detect_and_merge_close_nodes(epsilon)` объединяет узлы ближе порога с усреднением значений
- Хранение исходных и нормализованных координат позволяет избежать повторных преобразований
- Поля `min_distance` и `has_close_nodes` вычисляются один раз при построении и кэшируются

### Шаг 2.1.7.3: Структура для базисного интерполяционного полинома

**Структура `InterpolationBasis`:**
```cpp
// Назначение: хранение параметров и состояния интерполяционного полинома P_int(x)
struct InterpolationBasis {
    // Ссылка на узлы (композиция или агрегация)
    InterpolationNodeSet nodes;        // Набор узлов интерполяции
    
    // Тип интерполяции (определяет внутреннее представление)
    enum class Method {
        BARYCENTRIC_TYPE1,   // Барицентрическая форма первого типа (рекомендуемая)
        BARYCENTRIC_TYPE2,   // Барицентрическая форма второго типа (для узлов Чебышёва)
        LAGRANGE_DIRECT      // Прямая форма Лагранжа (для малых m)
    } method;
    
    // Параметры барицентрической интерполяции
    std::vector<double> bary_weights;  // Веса w_e для барицентрической формулы
    double weight_scale;               // Масштабирующий коэффициент весов
    
    // Кэшированные произведения для ускорения вычислений
    std::vector<double> weighted_values; // w_e * f(z_e) для числителя формулы
    
    // Флаги состояния
    bool is_built;                     // Построен ли полином
    bool is_stable;                    // Численная устойчивость (число обусловленности)
    double condition_number;           // Число обусловленности матрицы интерполяции
    
    // Методы доступа (логически):
    // • evaluate(double x) → значение P_int(x)
    // • evaluate_norm(double x_norm) → значение в нормализованных координатах
    // • evaluate_derivative(int order, double x) → производная заданного порядка
};
```

**Особенности реализации:**
- При построении автоматически выбирается оптимальный метод на основе `nodes.count`
- Веса вычисляются через логарифмический подход для предотвращения переполнения
- Кэш `weighted_values` обновляется автоматически при изменении значений `f(z_e)`
- Поле `condition_number` вычисляется через оценку чувствительности к возмущениям узлов

### Шаг 2.1.7.4: Структура для весового множителя

**Структура `WeightMultiplier`:**
```cpp
// Назначение: хранение параметров весового множителя W(x) = ∏(x - z_e)
struct WeightMultiplier {
    // Ссылка на узлы (разделяемая с InterpolationBasis для согласованности)
    const InterpolationNodeSet* nodes_ptr; // Указатель на набор узлов
    
    // Два взаимоисключающих представления (хранить только одно активное)
    enum class Representation {
        ROOTS_ONLY,      // Только корни (рекомендуется для m > 15)
        COEFFICIENTS,    // Явные коэффициенты (для m ≤ 15)
        HYBRID           // Оба представления (для диагностики)
    } representation;
    
    // Представление через корни (всегда доступно)
    bool roots_valid;                  // Флаг достоверности корней
    // (корни хранятся в nodes_ptr->x_norm, не дублируются)
    
    // Представление через коэффициенты (опционально)
    bool coeffs_valid;                 // Флаг достоверности коэффициентов
    std::vector<double> coeffs_norm;   // Коэффициенты в нормализованных координатах
    std::vector<double> coeffs_orig;   // Коэффициенты в исходных координатах (лениво вычисляются)
    
    // Кэшированные значения для ускорения оптимизации
    struct EvaluationCache {
        bool valid;                    // Актуальность кэша
        std::vector<double> x_points;  // Точки, для которых закэшированы значения
        std::vector<double> values;    // W(x) в точках x_points
        std::vector<double> deriv1;    // W'(x) в точках x_points
        std::vector<double> deriv2;    // W''(x) в точках x_points
    } cache_x, cache_y, cache_quad;    // Отдельные кэши для разных типов точек
    
    // Метаданные
    int degree;                        // Степень полинома (равна nodes.count)
    double norm_factor;                // Нормализующий множитель для исходных координат
    
    // Методы доступа (логически):
    // • evaluate(double x) → значение W(x) с автоматическим выбором метода
    // • evaluate_with_derivatives(double x, double& w, double& w1, double& w2) → значение и производные
    // • invalidate_cache() → сброс всех кэшей при изменении узлов
};
```

**Особенности реализации:**
- Разделяемое владение узлами через указатель предотвращает дублирование данных
- При `m > 15` автоматически отключается построение коэффициентов для предотвращения неустойчивости
- Кэши организованы по типам точек (аппроксимирующие, отталкивающие, квадратура) для эффективной инвалидации
- Метод `evaluate_with_derivatives` использует логарифмическое дифференцирование для численной устойчивости

### Шаг 2.1.7.5: Структура для корректирующего полинома

**Структура `CorrectionPolynomial`:**
```cpp
// Назначение: хранение параметров и состояния корректирующего полинома Q(x)
struct CorrectionPolynomial {
    // Параметры базиса
    enum class BasisType {
        MONOMIAL,      // Стандартный базис: 1, x, x², ...
        CHEBYSHEV      // Базис Чебышёва: T₀(t), T₁(t), ...
    } basis_type;
    
    int degree;                        // Степень полинома: deg_Q = n - m
    int n_free;                        // Число свободных параметров: deg_Q + 1
    
    // Параметры нормализации (для базиса Чебышёва)
    double norm_center;                // Центр интервала [a, b]
    double norm_scale;                 // Масштаб интервала (b - a)
    
    // Коэффициенты (вектор свободных параметров для оптимизатора)
    std::vector<double> coeffs;        // q₀, q₁, ..., q_{deg_Q}
    bool coeffs_valid;                 // Флаг инициализации коэффициентов
    
    // Кэшированные значения базисных функций
    struct BasisCache {
        bool valid;
        std::vector<double> points;    // Точки оценки
        // Трёхмерный кэш: [точка][базисная_функция][производная: 0=значение, 1=первая, 2=вторая]
        std::vector<std::vector<std::array<double, 3>>> values;
    } cache_x, cache_y, cache_quad;
    
    // Матрица "жёсткости" для регуляризационного члена
    struct RegularizationMatrix {
        bool valid;
        std::vector<std::vector<double>> K; // K[k][l] = ∫(φₖ·W)''·(φₗ·W)'' dx
        double gamma;                       // Текущее значение параметра регуляризации
    } reg_matrix;
    
    // Метаданные инициализации
    enum class InitMethod {
        ZERO,              // Нулевая инициализация
        LEAST_SQUARES,     // Инициализация через МНК
        RANDOM             // Случайная инициализация
    } init_method;
    double init_quality;   // Качество инициализации (значение функционала)
    
    // Методы доступа (логически):
    // • evaluate(double x) → значение Q(x)
    // • evaluate_basis(int k, double x, int derivative_order) → k-я базисная функция
    // • compute_gradient_component(int k, const CompositeState& state) → градиент по qₖ
};
```

**Особенности реализации:**
- Трёхмерный кэш базисных функций позволяет эффективно получать значения и производные за O(1)
- Матрица регуляризации вычисляется один раз при построении и обновляется только при изменении `γ`
- При смене базиса (`MONOMIAL` ↔ `CHEBYSHEV`) автоматически пересчитываются коэффициенты через преобразование базиса
- Кэши инвалидируются при изменении коэффициентов через метод `set_coeffs(const std::vector<double>& new_coeffs)`

### Шаг 2.1.7.6: Структура для составного полинома (итоговая параметризация)

**Структура `CompositeParameterization`:**
```cpp
// Назначение: объединение всех компонентов в единую параметризацию F(x) = P_int(x) + Q(x)·W(x)
struct CompositeParameterization {
    // Константные параметры задачи
    int total_degree;                  // Степень итогового полинома n
    int num_constraints;               // Число интерполяционных узлов m
    double interval_a, interval_b;     // Границы интервала определения [a, b]
    
    // Компоненты параметризации (агрегация по значению)
    InterpolationBasis basis;          // Базисный полином P_int(x)
    WeightMultiplier weight;           // Весовой множитель W(x)
    CorrectionPolynomial correction;   // Корректирующий полином Q(x)
    
    // Состояние параметризации
    enum class State {
        UNBUILT,       // Параметризация не построена
        VALIDATED,     // Построена и прошла верификацию
        OPTIMIZING,    // В процессе оптимизации
        OPTIMIZED      // Оптимизация завершена
    } state;
    
    // Диагностические метрики качества параметризации
    struct QualityMetrics {
        double interp_max_error;       // Макс. ошибка интерполяции
        double basis_condition;        // Число обусловленности базиса
        double scale_balance;          // Баланс масштабов компонентов
        bool is_numerically_stable;    // Общий флаг устойчивости
    } quality;
    
    // Кэш для ускорения вычисления функционала
    struct FunctionalCache {
        bool valid;
        // Закэшированные значения компонентов в точках данных
        std::vector<double> P_at_x;    // P_int(x_i)
        std::vector<double> W_at_x;    // W(x_i)
        std::vector<double> P_at_y;    // P_int(y_j)
        std::vector<double> W_at_y;    // W(y_j)
        // Узлы и веса квадратуры для регуляризационного члена
        std::vector<double> quad_nodes;
        std::vector<double> quad_weights;
    } functional_cache;
    
    // Методы доступа высокого уровня (логически):
    // • evaluate(double x) → F(x) через ленивую оценку
    // • compute_objective(const std::vector<double>& q) → значение функционала J(q)
    // • compute_gradient(const std::vector<double>& q, std::vector<double>& grad) → градиент ∇J(q)
    // • validate() → выполнение верификации (подшаг 2.1.6) и обновление quality
    // • rebuild_cache() → перестроение всех кэшей после изменения параметров
};
```

**Особенности реализации:**
- Агрегация компонентов по значению (не по указателю) упрощает управление жизненным циклом
- Поле `state` обеспечивает контроль последовательности операций (нельзя оптимизировать непроверенную параметризацию)
- Диагностические метрики `quality` заполняются методом `validate()` и используются для принятия решений
- Функциональный кэш `functional_cache` строится один раз перед оптимизацией и значительно ускоряет вычисления

### Шаг 2.1.7.7: Вспомогательные структуры для управления жизненным циклом

**Структура `ParameterizationBuilder`:**
```cpp
// Назначение: фасад для пошагового построения параметризации с валидацией
class ParameterizationBuilder {
private:
    CompositeParameterization param;   // Строимая параметризация
    bool step1_nodes_validated;        // Флаг завершения шага 1.1
    bool step1_corrected;              // Флаг завершения шага 1.2
    // ... флаги для остальных шагов
    
public:
    // Пошаговый интерфейс построения
    bool validate_nodes(const InputData& data);      // Шаг 1.1
    bool correct_formulation(InputData& data);       // Шаг 1.2
    bool build_basis();                              // Шаг 2.1.2
    bool build_weight_multiplier();                  // Шаг 2.1.3
    bool build_correction_poly();                    // Шаг 2.1.4
    bool assemble_composite();                       // Шаг 2.1.5
    bool verify_parameterization();                  // Шаг 2.1.6
    
    // Получение результата
    CompositeParameterization take_result();         // Передача владения готовой параметризацией
    
    // Диагностика
    std::vector<std::string> get_build_log();        // Хронология построения с ошибками/предупреждениями
};
```

**Структура `ParameterizationWorkspace`:**
```cpp
// Назначение: управление памятью и временными данными во время оптимизации
class ParameterizationWorkspace {
private:
    // Выравненные буферы для векторизованных вычислений
    AlignedVector<double, 32> temp_buffer_1;  // Временный буфер 1 (выравнивание 32 байта для AVX)
    AlignedVector<double, 32> temp_buffer_2;  // Временный буфер 2
    
    // Пул памяти для частых аллокаций/деаллокаций
    MemoryPool<double> value_pool;            // Пул для векторов значений
    
public:
    // Интерфейс выделения памяти
    std::vector<double>* allocate_values(size_t size);
    void release_values(std::vector<double>* ptr);
    
    // Интерфейс для векторизованных операций
    void compute_batch_product(const double* a, const double* b, double* result, size_t size);
};
```

### Шаг 2.1.7.8: Стратегии оптимизации памяти и производительности

**Стратегия 1: Ленивая инициализация тяжёлых компонентов**
- Коэффициенты `W(x)` в исходных координатах вычисляются только при запросе
- Матрица регуляризации строится только если `γ > 0`
- Кэши для отталкивающих точек строятся только если `N_y > 0`

**Стратегия 2: Разделение горячих и холодных данных**
- Горячие данные (используются на каждой итерации оптимизации):
  * Коэффициенты `q_k`
  * Кэши `W(x_i)`, `W(y_j)`
  * Базисные функции в точках данных
- Холодные данные (используются редко):
  * Исходные узлы интерполяции
  * Диагностические метрики
  * Коэффициенты в исходных координатах
- Размещение в разных участках памяти для улучшения локальности кэша процессора

**Стратегия 3: Выравнивание данных для векторизации**
- Все векторы значений выделяются с выравниванием 32 байта (для AVX) или 64 байта (для AVX-512)
- Использование пользовательского аллокатора с выравниванием:
  ```cpp
  template<typename T, size_t ALIGN>
  class AlignedAllocator { /* реализация выравнивающего аллокатора */ };
  ```
- Контроль выравнивания через статические проверки на этапе компиляции

**Стратегия 4: Минимизация аллокаций во время оптимизации**
- Предварительное выделение всех необходимых буферов перед началом оптимизации
- Использование пула памяти для временных векторов вместо частых `new/delete`
- Избегание копирования данных через передачу по ссылке и семантику перемещения

### Шаг 2.1.7.9: Механизмы инвалидации кэшей и поддержания согласованности

**Иерархия зависимостей кэшей:**
```
Изменение узлов интерполяции
  → Инвалидация: базисного полинома, весового множителя, составного полинома
  → Каскадная инвалидация: всех функциональных кэшей

Изменение коэффициентов Q(x)
  → Инвалидация: только функциональных кэшей (базис и вес остаются неизменными)

Изменение параметра γ
  → Инвалидация: матрицы регуляризации и связанного кэша
```

**Реализация механизма инвалидации:**
1. Каждая структура данных содержит метод `invalidate_dependent_caches()`
2. При изменении параметров вызывается цепочка инвалидации:
   ```cpp
   correction.set_coeffs(new_coeffs);
   // Внутри set_coeffs():
   //   1. Обновить коэффициенты
   //   2. Вызвать invalidate_dependent_caches()
   //   3. Который вызывает param.functional_cache.valid = false;
   ```
3. Перед использованием кэша проверяется флаг `valid`:
   ```cpp
   if (!functional_cache.valid) {
       rebuild_functional_cache();
   }
   ```

**Защита от ошибок использования неактуальных данных:**
- В режиме отладки (`#ifdef DEBUG`) добавить временные метки (timestamps) для каждого кэша
- При доступе к кэшу проверять, что его временная метка новее меток зависимых компонентов
- При обнаружении несогласованности — аварийное завершение с диагностикой

### Шаг 2.1.7.10: Интеграция структур данных с последующими этапами алгоритма

**Интерфейс для оптимизатора:**
```cpp
// Функтор для оптимизатора L-BFGS
class ObjectiveFunctor {
private:
    const CompositeParameterization& param;  // Ссылка на параметризацию (без изменения)
    const OptimizationData& opt_data;        // Данные задачи (аппроксимирующие/отталкивающие точки)
    
public:
    // Вычисление значения функционала
    double operator()(const std::vector<double>& q) const;
    
    // Вычисление градиента
    void gradient(const std::vector<double>& q, std::vector<double>& grad) const;
    
    // Комбинированное вычисление (для оптимизаторов, требующих одновременного расчёта)
    void evaluate_with_gradient(const std::vector<double>& q, 
                               double& f, std::vector<double>& grad) const;
};
```

**Подготовка к оптимизации:**
1. После успешной верификации (шаг 2.1.6) вызвать `param.rebuild_functional_cache()`
2. Создать функтор `ObjectiveFunctor` с ссылкой на параметризацию и данные задачи
3. Передать функтор оптимизатору вместе с начальными коэффициентами `param.correction.coeffs`
4. После завершения оптимизации обновить коэффициенты: `param.correction.set_coeffs(optimal_q)`

**Экспорт результатов:**
- Метод `param.export_to_coefficients()` — построение явных коэффициентов `F(x)` для экспорта
- Метод `param.export_to_evaluation_grid(std::vector<double> grid)` — вычисление значений на сетке для визуализации
- Метод `param.export_diagnostics()` — генерация структуры с диагностическими метриками для отчёта

Этот план обеспечивает чёткую архитектуру данных с разделением ответственности, оптимизацией памяти и производительности, надёжными механизмами поддержания согласованности, и плавную интеграцию с последующими этапами алгоритма. Структуры данных спроектированы для эффективной работы в режиме многократных вычислений функционала и его градиента во время оптимизации.