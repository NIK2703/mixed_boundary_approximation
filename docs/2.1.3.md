## Подшаг 2.1.3: Построение весового множителя `W(x) = Π(x - z_e)` — подробный план реализации на C++

### Шаг 2.1.3.1: Математическая формулировка весового множителя

**Определение полинома с заданными корнями:**
- Весовой множитель определяется как монический полином степени `m` с корнями в интерполяционных узлах:
  ```
  W(x) = ∏_{e=1..m} (x - z_e) = (x - z_1)(x - z_2)...(x - z_m)
  ```
- Ключевые свойства:
  * Старший коэффициент равен 1 (монический полином)
  * `W(z_e) = 0` для всех узлов интерполяции по построению
  * Степень полинома точно равна числу узлов `m` при условии уникальности корней

**Разложение по коэффициентам:**
- Полином представляется в канонической форме:
  ```
  W(x) = x^m + w_{m-1}·x^{m-1} + w_{m-2}·x^{m-2} + ... + w_1·x + w_0
  ```
- Коэффициенты связаны с корнями через элементарные симметрические многочлены:
  * `w_{m-1} = -Σ z_e` (сумма корней с обратным знаком)
  * `w_{m-2} = +Σ_{e<k} z_e·z_k` (сумма попарных произведений)
  * `w_0 = (-1)^m · Π z_e` (произведение всех корней с чередующимся знаком)

### Шаг 2.1.3.2: Алгоритм инкрементального построения коэффициентов

**Итеративное умножение линейных множителей:**
1. Инициализация:
   - Создать массив коэффициентов `coeffs` размером `m + 1`
   - Установить начальное состояние для полинома степени 0: `coeffs[0] = 1.0` (представление константы 1)

2. Последовательное умножение на `(x - z_e)` для каждого узла:
   - Для текущего полинома степени `k` с коэффициентами `[c_k, c_{k-1}, ..., c_0]`:
     ```
     Новый полином = (старый полином) × (x - z_e)
                   = x·(старый полином) - z_e·(старый полином)
     ```
   - Обновление коэффициентов выполняется справа налево во избежание перезаписи:
     ```
     для i от текущая_степень + 1 до 1 (в обратном порядке):
         coeffs[i] = coeffs[i-1] - z_e · coeffs[i]
     coeffs[0] = -z_e · coeffs[0]
     ```

3. После обработки всех `m` узлов массив `coeffs` содержит коэффициенты полинома `W(x)` в порядке убывания степеней

**Численная стабилизация при умножении:**
- При большом разбросе узлов (`max|z_e| / min|z_e| > 1e6`) применять нормализацию перед построением:
  * Сдвиг корней к нулю: `z_e' = z_e - mean(z)`
  * Масштабирование: `z_e'' = z_e' / scale`, где `scale = std_dev(z)` или `(b - a)/2`
- После построения коэффициентов выполнить обратное преобразование через биномиальные разложения

### Шаг 2.1.3.3: Представление данных и структуры хранения

**Основная структура `WeightPolynomial`:**
```cpp
struct WeightPolynomial {
    // Корни полинома (исходные узлы интерполяции)
    std::vector<double> roots;           // z_e в исходных координатах
    std::vector<double> roots_norm;      // z_e в нормализованных координатах [-1, 1]
    
    // Коэффициенты полинома
    std::vector<double> coeffs;          // [1.0, w_{m-1}, ..., w_0] — размер m+1
    bool coeffs_valid;                   // флаг достоверности коэффициентов
    
    // Параметры нормализации
    double shift;                        // сдвиг для преобразования координат
    double scale;                        // масштаб для преобразования координат
    
    // Метаданные
    int degree;                          // степень полинома (равна m)
    double min_root_distance;            // минимальное расстояние между корнями
};
```

**Альтернативное представление через корни (для численной устойчивости):**
- При высоких степенях (`m > 20`) хранить только корни без явных коэффициентов
- Вычислять значения полинома напрямую через произведение `(x - z_e)`
- Преимущество: избегание катастрофической потери точности при вычислении коэффициентов
- Недостаток: невозможность аналитического вычисления производных высоких порядков

### Шаг 2.1.3.4: Вычисление значений полинома

**Схема Горнера для оценки через коэффициенты:**
- Для точки `x` вычисление значения выполняется за O(m) операций:
  ```
  result = coeffs[0]  // старший коэффициент = 1.0
  для i от 1 до m:
      result = result * x + coeffs[i]
  ```
- Преимущество: минимальное число операций и хорошая численная устойчивость для умеренных степеней (`m ≤ 30`)

**Прямое вычисление через корни:**
- Альтернативный метод без использования коэффициентов:
  ```
  result = 1.0
  для каждого корня z_e:
      result = result * (x - z_e)
  ```
- Преимущество: максимальная точность при больших степенях
- Недостаток: вычислительная сложность O(m) с большим константным множителем из-за отсутствия оптимизации

**Гибридная стратегия выбора метода:**
- Если `m ≤ 15` — использовать схему Горнера (максимальная скорость)
- Если `15 < m ≤ 40` — использовать схему Горнера с предварительной нормализацией координат
- Если `m > 40` — использовать прямое вычисление через корни для сохранения точности

### Шаг 2.1.3.5: Вычисление производных полинома

**Аналитические формулы для производных:**
- Первая производная через коэффициенты:
  ```
  W'(x) = m·x^{m-1} + (m-1)·w_{m-1}·x^{m-2} + ... + w_1
  ```
  Вычисляется схемой Горнера по модифицированному массиву коэффициентов

- Вторая производная:
  ```
  W''(x) = m·(m-1)·x^{m-2} + (m-1)·(m-2)·w_{m-1}·x^{m-3} + ... + 2·w_2
  ```

**Эффективное вычисление через рекуррентные соотношения:**
- При использовании представления через корни применить логарифмическое дифференцирование:
  ```
  W'(x) / W(x) = Σ_{e=1..m} 1 / (x - z_e)
  ⇒ W'(x) = W(x) · Σ 1/(x - z_e)
  
  W''(x) / W(x) = [Σ 1/(x - z_e)]² - Σ 1/(x - z_e)²
  ⇒ W''(x) = W(x) · ([Σ 1/(x - z_e)]² - Σ 1/(x - z_e)²)
  ```
- Преимущество: одновременное вычисление значения и обеих производных за один проход по корням

**Оптимизация для регуляризационного члена:**
- Для интеграла `∫(F''(x))²dx` требуется `W''(x)` во многих точках
- Предварительно вычислить и закэшировать значения `W(x)`, `W'(x)`, `W''(x)` в узлах квадратурной формулы
- Использовать адаптивное квадратурное интегрирование с кэшированием для ускорения

### Шаг 2.1.3.6: Кэширование значений для оптимизации

**Стратегия предварительных вычислений:**
1. Для всех аппроксимирующих точек `{x_i}`:
   - Вычислить и сохранить `W(x_i)`, `W'(x_i)`, `W''(x_i)` в векторах `cache_W_x`, `cache_W1_x`, `cache_W2_x`
   - Размер кэша: `N_x` (число аппроксимирующих точек)

2. Для всех отталкивающих точек `{y_j}`:
   - Аналогично вычислить и сохранить значения в отдельных кэшах `cache_W_y`, `cache_W1_y`, `cache_W2_y`
   - Размер кэша: `N_y` (число отталкивающих точек)

3. Для численного интегрирования регуляризационного члена:
   - Сгенерировать узлы квадратуры Гаусса-Лежандра на `[a, b]` (10–20 точек достаточно для полиномов)
   - Вычислить и сохранить значения во всех узлах квадратуры

**Экономия вычислительных ресурсов:**
- Без кэширования: каждая итерация оптимизации требует O((N_x + N_y + N_quad)·m) операций
- С кэшированием: вычисления `W(x)` выполняются один раз до оптимизации, последующие итерации используют кэш
- Ускорение: до 10–100× при большом числе итераций оптимизации

### Шаг 2.1.3.7: Верификация корректности построения

**Тест на нулевые значения в узлах интерполяции:**
1. Для каждого корня `z_e` вычислить `W(z_e)` через оба метода (коэффициенты и прямое произведение)
2. Проверить условие: `|W(z_e)| < ε_zero`, где `ε_zero = 1e-12·max(1, |z_e|^m)`
3. При нарушении:
   - Диагностировать источник ошибки (потеря точности при построении коэффициентов)
   - Переключиться на представление через корни без коэффициентов
   - Повторить верификацию

**Тест на моничность полинома:**
1. Вычислить отношение старшего коэффициента к 1.0: `|coeffs[0] - 1.0|`
2. Для нормализованных корней ожидаемое отклонение: `< 1e-14`
3. Для ненормализованных корней с большим разбросом допустимо отклонение до `1e-10`

**Тест на согласованность представлений:**
1. Выбрать 5–10 случайных точек в интервале `[a, b]`
2. Вычислить значения `W(x)` тремя способами:
   * Через коэффициенты (схема Горнера)
   * Через прямое произведение корней
   * Через рекуррентные соотношения для производных
3. Проверить согласованность результатов с относительной погрешностью `< 1e-8`

### Шаг 2.1.3.8: Обработка крайних случаев

**Случай отсутствия интерполяционных узлов (`m = 0`):**
- Весовой множитель вырождается в константу: `W(x) = 1`
- Специальная обработка:
  * Установить `degree = 0`, `coeffs = {1.0}`
  * Отключить все операции с корнями
  * Оптимизировать вычисления: пропускать умножение на `W(x)` в формуле `F(x) = P_int(x) + Q(x)·W(x)`

**Случай единственного узла (`m = 1`):**
- Полином первой степени: `W(x) = x - z_1`
- Коэффициенты: `coeffs = {1.0, -z_1}`
- Производные: `W'(x) = 1`, `W''(x) = 0` (вторая производная тождественно нулевая)
- Оптимизация: аналитическое вычисление без схемы Горнера

**Случай кратных корней:**
- Обнаружение через минимальное расстояние между узлами: `d_min < ε_close = 1e-10·(b - a)`
- При обнаружении кратного корня кратности `p`:
  * Формировать множитель `(x - z)^p` вместо `p` отдельных линейных множителей
  * Модифицировать параметризацию: `F(x) = P_int(x) + Q(x)·(x - z)^p·W_remaining(x)`
  * Уменьшить эффективную степень свободного полинома: `deg_Q = n - m - (p - 1)`

**Случай экстремально больших степеней (`m > 50`):**
- Предупреждение о потенциальной неустойчивости глобального полинома
- Рекомендация перехода к локальным базисам (сплайны, радиальные базисные функции)
- Если продолжение необходимо:
  * Использовать только представление через корни (без коэффициентов)
  * Применять арифметику повышенной точности (`long double` или библиотеки многократной точности)
  * Ограничить число итераций оптимизации из-за высокой вычислительной сложности

### Шаг 2.1.3.9: Интеграция с компонентами полной параметризации

**Интерфейс для сборки итогового полинома `F(x)`:**
- Метод `multiply_by_Q(const std::vector<double>& q_coeffs, std::vector<double>& result_coeffs)`:
  * Выполняет свёртку коэффициентов `Q(x)` и `W(x)` для получения коэффициентов произведения
  * Результат: полином степени `n` с коэффициентами в `result_coeffs`
- Метод `evaluate_product(double x, const std::vector<double>& q_coeffs)`:
  * Вычисляет значение `Q(x)·W(x)` без явного построения коэффициентов
  * Использует кэшированные значения `W(x)` и схему Горнера для `Q(x)`

**Подготовка данных для градиента функционала:**
- Предварительно вычислить базисные функции для градиента:
  ```
  φ_k(x) = x^k · W(x),  k = 0..(n - m)
  ```
- Для каждой точки данных `{x_i}`, `{y_j}` сохранить значения всех базисных функций
- Для регуляризационного члена предварительно вычислить матрицу интегралов:
  ```
  K_{kl} = ∫ [d²/dx² (x^k·W(x))] · [d²/dx² (x^l·W(x))] dx
  ```
  Эта матрица используется для быстрого вычисления градиента регуляризационного члена

Этот план обеспечивает построение численно устойчивого весового множителя с автоматическим выбором оптимального представления (коэффициенты или корни), эффективным кэшированием для ускорения оптимизации, и полной подготовкой всех необходимых компонентов (значений, производных, базисных функций) для интеграции в параметризацию полного решения `F(x) = P_int(x) + Q(x)·W(x)`.