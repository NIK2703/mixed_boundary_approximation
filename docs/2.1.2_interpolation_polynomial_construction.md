## Подшаг 2.1.2: Построение базисного интерполяционного полинома `P_int(x)` — подробный план реализации на C++

### Шаг 2.1.2.1: Предварительная подготовка и валидация узлов интерполяции

**Сортировка и нормализация узлов:**
- Отсортировать узлы `z_e` по возрастанию абсциссы для улучшения численной устойчивости
- Сохранить исходные индексы в отдельном массиве `original_indices` для восстановления порядка при диагностике ошибок
- Применить нормализацию координат к интервалу `[-1, 1]`:
  * Вычислить центр: `x_center = (a + b) / 2`
  * Вычислить масштаб: `x_scale = (b - a) / 2`
  * Преобразовать узлы: `z_e_norm = (z_e - x_center) / x_scale`
- Сохранить параметры нормализации для последующего обратного преобразования

**Детектирование и обработка близких узлов:**
- Вычислить попарные расстояния между нормализованными узлами: `d_{ek} = |z_e_norm - z_k_norm|`
- Определить порог близости: `ε_close = max(1e-12, 1e-4 / m)` (зависит от числа узлов)
- Для каждой пары узлов с `d_{ek} < ε_close`:
  * Если значения `f(z_e)` и `f(z_k)` отличаются менее чем на `ε_value = 1e-10·max(1, |f(z_e)|, |f(z_k)|)` — объединить узлы с усреднением значений
  * Если значения различаются значительно — сформировать критическую ошибку «Противоречивые интерполяционные условия в близких точках»
- Обновить эффективное число узлов `m_eff` после объединения

### Шаг 2.1.2.2: Выбор метода интерполяции на основе характеристик задачи

**Критерии выбора метода:**
- Если `m_eff ≤ 10` — использовать **классическую форму Лагранжа** (простота реализации, достаточная точность)
- Если `10 < m_eff ≤ 50` — использовать **барицентрическую форму первого типа** (оптимальный баланс скорости и устойчивости)
- Если `m_eff > 50` — использовать **барицентрическую форму второго типа с узлами Чебышёва** (максимальная устойчивость) или рекомендовать переход к сплайнам

**Барицентрическая форма первого типа (рекомендуемая для большинства случаев):**
- Веса вычисляются как: `w_e = (-1)^e / [Π_{k≠e} (z_e - z_k)]` для равноотстоящих узлов
- Для произвольных узлов: `w_e = 1 / Π_{k≠e} (z_e - z_k)` с последующей нормализацией
- Преимущество: значение полинома вычисляется за O(m) вместо O(m²) для классического Лагранжа

**Барицентрическая форма второго типа (для высоких степеней):**
- Использует предварительно вычисленные веса Чебышёва: `w_e = (-1)^e · sin(π·e/m)` для узлов на равномерной сетке в `[-1, 1]`
- Требует преобразования произвольных узлов к узлам Чебышёва через нелинейное отображение
- Обеспечивает экспоненциальную сходимость для гладких функций

### Шаг 2.1.2.3: Вычисление барицентрических весов с численной стабилизацией

**Логарифмический подход для предотвращения переполнения:**
1. Для каждого узла `z_e`:
   - Инициализировать `log_abs_weight = 0.0`, `sign_weight = +1`
   - Для каждого другого узла `z_k` (`k ≠ e`):
     * Вычислить разность: `diff = z_e - z_k`
     * Обновить знак: `sign_weight *= sign(diff)`
     * Обновить логарифм модуля: `log_abs_weight -= log(|diff|)`
   - Преобразовать обратно: `abs_weight = exp(log_abs_weight)`
   - Итоговый вес: `w_e = sign_weight * abs_weight`

2. Нормализация весов для улучшения масштаба:
   - Найти максимальный модуль: `w_max = max(|w_e|)`
   - Нормализовать: `w_e = w_e / w_max`
   - Сохранить масштабирующий коэффициент `scale_w = w_max` для корректного вычисления значений

**Обработка вырожденных случаев:**
- Если `|diff| < ε_min = 1e-15` для некоторой пары узлов — применить стратегию из шага 2.1.2.1 (объединение узлов)
- Если `log_abs_weight` выходит за пределы допустимого диапазона (`> 700` или `< -700` для `double`) — переключиться на арифметику `long double` или применить адаптивное масштабирование

### Шаг 2.1.2.4: Реализация вычислителя значения полинома

**Алгоритм барицентрической оценки:**
1. Для заданной точки `x`:
   - Проверить совпадение с узлами интерполяции (с точностью `ε_node = 1e-12`):
     * Если `|x - z_e| < ε_node` для некоторого `e` — вернуть `f(z_e)` напрямую (избегание деления на ноль)
   - Вычислить числитель: `numerator = Σ_{e=1..m} (w_e · f(z_e)) / (x - z_e)`
   - Вычислить знаменатель: `denominator = Σ_{e=1..m} w_e / (x - z_e)`
   - Вернуть значение: `P_int(x) = numerator / denominator`

2. Оптимизация для множественных вычислений:
   - Предварительно вычислить и закэшировать произведения `w_e · f(z_e)` в массиве `weighted_values`
   - Для точек данных `{x_i}` и `{y_j}` выполнить пакетную оценку с минимизацией повторных вычислений

**Численная защита:**
- При малых значениях знаменателя (`|denominator| < ε_denom = 1e-14·max(1, |numerator|)`) применить интерполяцию между ближайшими узлами
- Контроль потери точности через сравнение с альтернативным методом (например, схемой Горнера для малых `m`)

### Шаг 2.1.2.5: Вычисление производных полинома для регуляризационного члена

**Аналитическая формула первой производной (барицентрическая форма):**
```
P_int'(x) = [P_int(x) · Σ w_e/(x - z_e)² - Σ w_e·f(z_e)/(x - z_e)²] / Σ w_e/(x - z_e)
```
- Требует вычисления дополнительных сумм с квадратами разностей в знаменателе
- Реализовать отдельный метод `evaluate_first_derivative(x)` с кэшированием промежуточных сумм

**Аналитическая формула второй производной:**
- Более сложное выражение, содержащее суммы с кубами разностей
- Альтернативный подход: численное дифференцирование через центральные разности с адаптивным шагом:
  ```
  P_int''(x) ≈ [P_int(x + h) - 2·P_int(x) + P_int(x - h)] / h²
  где h = max(1e-6, 1e-3·|x|, ε_machine·|x|)
  ```
- Для регуляризационного интеграла `∫(F''(x))²dx` предпочтительно использовать аналитическое выражение через коэффициенты полинома после сборки итогового `F(x)`

**Кэширование производных в точках данных:**
- Предварительно вычислить `P_int''(x_i)` и `P_int''(y_j)` для всех точек данных
- Сохранить в структурах `cached_second_derivatives_x` и `cached_second_derivatives_y`
- Использовать при вычислении градиента функционала для ускорения оптимизации

### Шаг 2.1.2.6: Верификация точности интерполяции

**Тест на точное воспроизведение узлов:**
1. Для каждого узла `z_e` вычислить значение полинома `P_int(z_e)` через обходной путь:
   - Использовать точку `x_test = z_e + δ`, где `δ = ε_test·(b - a)`, `ε_test = 1e-8`
   - Сравнить с предельным значением при `δ → 0`
2. Проверить отклонение: `|P_int(z_e) - f(z_e)| < ε_interp`, где `ε_interp = 1e-10·max(1, |f(z_e)|)`
3. При нарушении:
   - Повторить вычисление в арифметике `long double`
   - Если ошибка сохраняется — переключиться на метод Ньютона с разделёнными разностями

**Тест на устойчивость к возмущениям:**
1. Сгенерировать небольшие случайные возмущения узлов: `z_e_perturbed = z_e + ξ_e·ε_pert`, где `ξ_e ∈ [-1, 1]`, `ε_pert = 1e-8·(b - a)`
2. Построить полином по возмущённым узлам
3. Оценить изменение значения в контрольной точке `x_test = (a + b)/2`:
   - Если относительное изменение `> 10%` — выдать предупреждение о потенциальной неустойчивости
   - Рекомендовать снижение степени или использование сплайнов

### Шаг 2.1.2.7: Подготовка структур данных для последующих этапов

**Структура `InterpolationBasis`:**
```cpp
struct InterpolationBasis {
    // Исходные данные (нормализованные)
    std::vector<double> nodes_norm;      // z_e в [-1, 1]
    std::vector<double> values;          // f(z_e)
    int m_eff;                           // эффективное число узлов после объединения
    
    // Барицентрические веса
    std::vector<double> weights;         // w_e
    double weight_scale;                 // масштабирующий коэффициент
    
    // Параметры нормализации
    double x_center;                     // центр интервала [a, b]
    double x_scale;                      // масштаб интервала
    
    // Кэшированные данные для ускорения
    std::vector<double> weighted_values; // w_e * f(z_e)
    
    // Флаги состояния
    bool is_valid;
    std::string error_message;
};
```

**Методы интерфейса вычислителя:**
- `double evaluate(double x_original)` — вычисление значения в исходных координатах (автоматически применяет нормализацию)
- `double evaluate_norm(double x_norm)` — вычисление в нормализованных координатах (для внутреннего использования)
- `double evaluate_derivative_norm(double x_norm, int order)` — вычисление производной заданного порядка
- `void precompute_cache(const std::vector<double>& points)` — предварительное вычисление значений в заданных точках

### Шаг 2.1.2.8: Обработка специальных случаев

**Случай единственного узла (`m_eff = 1`):**
- Базисный полином вырождается в константу: `P_int(x) = f(z_1)`
- Барицентрические веса не требуются — использовать упрощённую реализацию
- Производные всех порядков равны нулю

**Случай двух узлов (`m_eff = 2`):**
- Полином является линейным: `P_int(x) = f(z_1) + (f(z_2) - f(z_1))·(x - z_1)/(z_2 - z_1)`
- Можно использовать прямую формулу вместо барицентрической для повышения точности
- Вторая производная тождественно равна нулю

**Случай равноотстоящих узлов:**
- Обнаружить через проверку постоянства разностей: `Δ = z_{e+1} - z_e ≈ const`
- При обнаружении применить оптимизированные веса: `w_e = (-1)^e · C(m, e)` (биномиальные коэффициенты)
- Ускорить вычисления за счёт симметрии весов

**Случай узлов Чебышёва:**
- Проверить соответствие формуле: `z_e = cos(π·(2e-1)/(2m))` для нормализованного интервала
- При подтверждении использовать предопределённые веса `w_e = (-1)^{e+1} · sin(π·(2e-1)/(2m))`
- Обеспечить максимальную устойчивость для высоких степеней интерполяции

Этот план обеспечивает построение численно устойчивого интерполяционного полинома с автоматическим выбором оптимального метода в зависимости от характеристик задачи, защитой от типичных численных ошибок и подготовкой всех необходимых компонентов (значений, производных, кэшей) для эффективной интеграции в последующие этапы оптимизации составного функционала.