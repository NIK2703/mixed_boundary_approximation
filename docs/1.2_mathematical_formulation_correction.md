## Подшаг 1.2: Коррекция математической постановки — подробный план реализации на C++

### Шаг 1.2.1: Анализ концептуальной проблемы в исходной формулировке

**Выявление семантического противоречия:**
- В исходном функционале отталкивающий член записан как `∑ B_j / |f(y_j) - F(y_j)|²`
- Проблема: точки `y_j` по определению являются «запрещёнными» — в них либо:
  * Функция `f` не определена (например, особенность, разрыв)
  * Значение `f(y_j)` физически недостижимо или нежелательно
  * Точка представляет собой границу запретной области, а не измерение
- Использование `f(y_j)` в знаменателе создаёт логическую несогласованность: если `f` не определена в `y_j`, то выражение бессмысленно

**Корректная математическая интерпретация:**
- Отталкивающая точка должна характеризоваться парой `(координата_x, запрещённое_значение_y*)`
- Физический смысл: «в точке с абсциссой `y_j` функция `F` не должна принимать значение `y_j^*`»
- Корректная форма отталкивающего члена:
  ```
  ∑ B_j / |y_j^* - F(y_j)|²
  ```
  где `y_j^*` — целевое запрещённое значение (не `f(y_j)`!)

### Шаг 1.2.2: Проектирование расширенной структуры данных для отталкивающих точек

**Рефакторинг контейнера отталкивающих точек:**
- Заменить простую пару `(координата, вес)` на тройку:
  ```
  struct RepulsionPoint {
      double x;        // Абсцисса точки (координата на оси X)
      double y_forbidden;  // Запрещённое значение функции (ордината на оси Y)
      double weight;   // Вес отталкивания B_j
  };
  ```
- Обеспечить обратную совместимость через конструкторы-адаптеры:
  * Конструктор из пары `(x, вес)` — для упрощённого интерфейса (автоматически устанавливает `y_forbidden = 0`)
  * Конструктор из тройки `(x, y*, вес)` — для полной спецификации

**Семантическая документация полей:**
- Поле `x`: позиция на оси абсцисс, где применяется отталкивание
- Поле `y_forbidden`: целевое значение, которого должна избегать аппроксимирующая функция `F(x)`
- Поле `weight`: интенсивность барьера (чем больше, тем сильнее «отталкивание»)

### Шаг 1.2.3: Алгоритм трансформации входных данных пользователя

**Сценарий 1: Явная спецификация запрещённых значений**
- Пользователь предоставляет тройки `(y_j, y_j^*, B_j)` через файл конфигурации или API
- Прямое преобразование в структуру `RepulsionPoint` без дополнительных вычислений
- Валидация: проверка, что `y_j^*` не совпадает с интерполяционными значениями `f(z_e)` при совпадении абсцисс

**Сценарий 2: Неявная интерпретация (совместимость с исходной формулировкой)**
- Если пользователь предоставляет только пары `(y_j, B_j)` (без `y_j^*`):
  * Вариант A (рекомендуемый): интерпретировать как «избегать нулевого значения» → `y_j^* = 0`
  * Вариант B (альтернативный): использовать значение из аппроксимирующего множества при ближайшей абсциссе → `y_j^* = f(x_i)`, где `|x_i - y_j| = min`
- Обязательно выдать предупреждение: «Не указаны запрещённые значения; применена эвристика по умолчанию»

**Сценарий 3: Границы запретных областей**
- Для случаев, когда запрещена целая область (например, `F(x) ∉ [y_min, y_max]`):
  * Создать две отталкивающие точки: `(x, y_min - ε, B)` и `(x, y_max + ε, B)`
  * Параметр `ε` — небольшой отступ для формирования «буфера безопасности»
  * Автоматически генерировать такие пары из спецификации интервала запрета

### Шаг 1.2.4: Валидация корректности преобразованных данных

**Проверка конфликтов с интерполяционными узлами:**
- Для каждой отталкивающей точки `(y_j, y_j^*)` проверить:
  * Если существует интерполяционный узел `(z_e, f(z_e))` с `|z_e - y_j| < ε_coord`:
    - И одновременно `|f(z_e) - y_j^*| < ε_value` → фатальный конфликт
    - Диагностика: «Отталкивание от значения, которое должно быть достигнуто интерполяцией»
- Пороги сравнения:
  * `ε_coord = 1e-9 * (b - a)` — для сравнения абсцисс
  * `ε_value = 1e-9 * max(|f(z_e)|, |y_j^*|, 1.0)` — для сравнения ординат

**Проверка физической осмысленности запрещённых значений:**
- Если все отталкивающие точки имеют одинаковое `y_j^* = C`, а аппроксимирующие точки сконцентрированы около `C`:
  * Выдать предупреждение: «Сильное отталкивание от области концентрации данных может привести к неустойчивому решению»
- Анализ расстояний: минимальное расстояние от `y_j^*` до ближайшего `f(x_i)` при совпадающих абсциссах
  * Если расстояние < 1% от диапазона значений данных → предупреждение о потенциальной несовместимости критериев

### Шаг 1.2.5: Модификация вычислительного ядра функционала

**Рефакторинг вычисления отталкивающего члена:**
- Заменить все обращения к `f(y_j)` на прямое использование `y_j^*` из структуры `RepulsionPoint`
- Обновить формулу вычисления:
  ```
  term_repulse = Σ [ B_j / max(ε_safe², (y_j^* - F(y_j))²) ]
  ```
  где `ε_safe` — минимальный порог для предотвращения деления на ноль (рекомендуется `1e-8`)

**Обновление градиента функционала:**
- Аналитический градиент по коэффициентам полинома `a_k` для отталкивающего члена:
  ```
  ∂term_repulse/∂a_k = Σ [ -2·B_j·(y_j^* - F(y_j))⁻³ · ∂F(y_j)/∂a_k ]
  ```
- Ключевое изменение: производная берётся от `(y_j^* - F(y_j))`, а не от `(f(y_j) - F(y_j))`
- Для полинома `F(x) = Σ a_k·x^k`: `∂F(y_j)/∂a_k = y_j^k`

**Интеграция с регуляризационным членом:**
- Убедиться, что модифицированный отталкивающий член корректно сочетается с интегралом гладкости
- Проверить масштабирование: значения отталкивающего члена должны быть сопоставимы с аппроксимирующим членом для стабильной оптимизации

### Шаг 1.2.6: Обработка крайних случаев и защита от ошибок

**Случай «нулевого расстояния»:**
- При инициализации полинома возможна ситуация, когда `F(y_j) ≈ y_j^*`
- Стратегия защиты:
  1. На этапе инициализации проверить все отталкивающие точки
  2. Если `|y_j^* - F(y_j)| < ε_init` (например, `1e-4`):
     * Сдвинуть начальное приближение полинома на небольшую величину
     * Или временно уменьшить вес `B_j` на первых итерациях оптимизации
  3. Залогировать событие для диагностики

**Случай «конфликтующих барьеров»:**
- Если для одной абсциссы `y_j` заданы несколько запрещённых значений `y_j^*(1)`, `y_j^*(2)`, ...:
  * Объединить в единый барьер: `term = Σ_k B_j(k) / |y_j^*(k) - F(y_j)|²`
  * Проверить, что запрещённые значения не образуют «ловушку» (например, `y_j^*(1) = 1.0`, `y_j^*(2) = 1.0001` с большими весами)
  * При обнаружении ловушки выдать предупреждение и предложить объединить барьеры

### Шаг 1.2.7: Документирование и пользовательский интерфейс

**Генерация пояснительного отчёта:**
- После коррекции постановки сформировать отчёт:
  ```
  Коррекция математической постановки отталкивающего критерия:
  • Исходная формулировка: Σ B_j / |f(y_j) - F(y_j)|²
  • Корректная формулировка: Σ B_j / |y_j^* - F(y_j)|²
  • Причина: в точках отталкивания функция f может быть не определена;
            критерий должен измерять расстояние до запрещённого
            значения, а не до несуществующего измерения.
  • Применённые преобразования: [список конкретных изменений]
  ```
- Включить в отчёт примеры корректного и некорректного использования

**Обновление пользовательской документации:**
- В интерфейсе ввода данных явно разделить поля:
  * «Координата точки отталкивания (X)»
  * «Запрещённое значение функции (Y*)»
  * «Сила отталкивания (вес)»
- Добавить валидацию на уровне интерфейса: запретить ввод только координаты без значения
- Предоставить примеры типичных сценариев:
  * Избегание нулевого значения: `(x=2.5, y*=0.0, B=100)`
  * Избегание области помех: `(x=3.1, y*=5.2, B=500)`

Этот план обеспечивает строгую математическую корректность постановки задачи, предотвращает логические противоречия в функционале, и предоставляет пользователю прозрачный механизм спецификации отталкивающих условий с защитой от распространённых ошибок интерпретации.