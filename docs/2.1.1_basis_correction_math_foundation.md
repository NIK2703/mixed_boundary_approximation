## Подшаг 2.1.1: Математическая основа параметризации «базис + коррекция» — подробный план реализации на C++

### Шаг 2.1.1.1: Формализация задачи с ограничениями

**Постановка исходной задачи:**
- Имеется пространство полиномов степени `n` с размерностью `dim = n + 1`
- Задано `m` линейных ограничений вида `F(z_e) = f(z_e)`, `e = 1..m`
- Требуется параметризовать подпространство решений, удовлетворяющих всем ограничениям

**Математическая проверка разрешимости:**
- Вычислить ранг системы ограничений через матрицу Вандермонда:
  ```
  V = [1, z_e, z_e², ..., z_eⁿ] для всех e = 1..m
  ```
- Проверить линейную независимость строк матрицы `V` с порогом `ε_rank = 1e-12`
- Если ранг `< m` — обнаружены линейно зависимые ограничения (например, повторяющиеся узлы `z_e`)
- При обнаружении зависимости: сформировать отчёт о конфликтующих узлах и их индексах

### Шаг 2.1.1.2: Теоретическое обоснование разложения

**Доказательство корректности тождества:**
1. Определить весовой множитель как многочлен с корнями в узлах интерполяции:
   ```
   W(x) = ∏_{e=1..m} (x - z_e)
   ```
   - Свойство: `W(z_e) = 0` для всех `e = 1..m` по построению
   
2. Построить базисный интерполяционный полином `P_int(x)` степени `≤ m-1`:
   - Существование и единственность гарантируются теоремой Лагранжа при условии уникальности узлов
   - Свойство: `P_int(z_e) = f(z_e)` для всех `e = 1..m`

3. Доказать, что любое решение имеет вид `F(x) = P_int(x) + Q(x)·W(x)`:
   - Необходимость: если `F(z_e) = f(z_e)`, то `F(z_e) - P_int(z_e) = 0`, следовательно `(F - P_int)` делится на `W(x)`
   - Достаточность: подстановка `x = z_e` даёт `F(z_e) = P_int(z_e) + Q(z_e)·0 = f(z_e)`

4. Определить допустимую степень корректирующего полинома:
   - `deg(F) = max(deg(P_int), deg(Q) + deg(W)) ≤ n`
   - Так как `deg(P_int) ≤ m-1` и `deg(W) = m`, то `deg(Q) ≤ n - m`
   - Количество свободных параметров: `n - m + 1`

### Шаг 2.1.1.3: Проверка условий применимости разложения

**Валидация предпосылок:**
1. Проверка неравенства степеней:
   - Условие: `n ≥ m - 1` (иначе невозможно построить полином, проходящий через все узлы)
   - При нарушении: сформировать ошибку «Степень полинома недостаточна для интерполяции всех узлов»

2. Проверка уникальности узлов интерполяции:
   - Для каждой пары узлов `(z_e, z_k)`, `e < k`:
     * Вычислить расстояние `d = |z_e - z_k|`
     * Если `d < ε_unique = 1e-12·(b - a)` — узлы считаются совпадающими
   - При обнаружении совпадающих узлов с разными значениями `f(z_e) ≠ f(z_k)`:
     * Сформировать фатальную ошибку «Противоречивые интерполяционные условия»
   - При совпадающих узлах с одинаковыми значениями:
     * Объединить узлы, уменьшив эффективное `m`

3. Проверка расположения узлов внутри интервала:
   - Все `z_e` должны удовлетворять условию `a ≤ z_e ≤ b` с допуском `ε_bound = 1e-9·(b - a)`
   - Узлы вне интервала допустимы математически, но требуют предупреждения о потенциальной неустойчивости

### Шаг 2.1.1.4: Предварительные вычисления для разложения

**Подготовка данных для весового множителя:**
1. Сортировка узлов интерполяции:
   - Отсортировать массив `z_e` по возрастанию для улучшения численной устойчивости
   - Сохранить перестановку индексов для восстановления исходного порядка при необходимости

2. Вычисление попарных расстояний между узлами:
   - Построить матрицу `D[e][k] = |z_e - z_k|` для диагностики близких узлов
   - Определить минимальное расстояние `d_min = min_{e≠k} D[e][k]`
   - Если `d_min < 0.01·(b - a)/m` — выдать предупреждение о потенциальной неустойчивости интерполяции

3. Оценка масштаба весового множителя:
   - Вычислить характерный масштаб `scale_W = ∏_{e=1..m} max(|z_e|, 1.0)`
   - Если `scale_W > 1e150` или `scale_W < 1e-150` — рекомендовать нормализацию координат

**Подготовка данных для базисного полинома:**
1. Анализ диапазона значений интерполяции:
   - Вычислить `f_min = min(f(z_e))`, `f_max = max(f(z_e))`
   - Оценить разброс `Δf = f_max - f_min`
   - При `Δf < 1e-12·max(|f_min|, |f_max|, 1.0)` — предупреждение о вырожденной задаче

2. Проверка на полиномиальную зависимость:
   - Для `m ≤ 4` проверить, лежат ли точки на полиноме низкой степени (линейном, квадратичном)
   - Это позволяет упростить `P_int(x)` и улучшить численную устойчивость

### Шаг 2.1.1.5: Проектирование структур данных для хранения разложения

**Структура `DecompositionMetadata`:**
- Поля для хранения метаинформации о разложении:
  * `int n_total` — исходная степень полинома `F(x)`
  * `int m_constraints` — число интерполяционных узлов
  * `int n_free` — число свободных параметров (`n - m + 1`)
  * `bool is_valid` — флаг корректности разложения
  * `std::string validation_message` — диагностическое сообщение при ошибках

**Структура `WeightMultiplier`:**
- Поля для весового множителя `W(x)`:
  * `std::vector<double> roots` — отсортированные узлы `z_e`
  * `std::vector<double> coeffs` — коэффициенты полинома `W(x)` (опционально, для аналитических операций)
  * `double min_root_distance` — минимальное расстояние между корнями (для диагностики)
  * `bool use_direct_evaluation` — флаг использования прямого вычисления через корни вместо коэффициентов

**Структура `InterpolationBasis`:**
- Поля для базисного полинома `P_int(x)`:
  * `std::vector<double> nodes` — узлы интерполяции (копия из `WeightMultiplier`)
  * `std::vector<double> values` — значения `f(z_e)` в узлах
  * `InterpolationMethod method` — перечисление: `LAGRANGE`, `BARYCENTRIC`, `NEWTON`
  * Объединение (union) для хранения весов в зависимости от метода:
    - Для барицентрического: `std::vector<double> barycentric_weights`
    - Для ньютоновского: `std::vector<double> divided_differences`

### Шаг 2.1.1.6: Верификация корректности разложения

**Тест на тождественное выполнение ограничений:**
1. Сгенерировать случайный корректирующий полином `Q_test(x)`:
   - Степень `deg_Q = n - m`
   - Коэффициенты — случайные числа из диапазона `[-1, 1]`

2. Построить тестовый полином `F_test(x) = P_int(x) + Q_test(x)·W(x)`

3. Проверить выполнение ограничений:
   - Для каждого узла `z_e` вычислить отклонение `δ_e = |F_test(z_e) - f(z_e)|`
   - Условие прохождения теста: `δ_e < ε_test = 1e-10·max(1, |f(z_e)|)` для всех `e`

4. При провале теста:
   - Диагностировать источник ошибки:
     * Если `|W(z_e)| > ε_test` — ошибка в построении весового множителя
     * Если `|P_int(z_e) - f(z_e)| > ε_test` — ошибка в построении базисного полинома
   - Переключиться на арифметику повышенной точности (`long double`) для повторной проверки

**Тест на полноту пространства решений:**
1. Сгенерировать `n_free + 1` линейно независимых полиномов `Q_k(x)`
2. Построить соответствующие `F_k(x) = P_int(x) + Q_k(x)·W(x)`
3. Проверить линейную независимость системы `{F_k(x)}` через определитель матрицы значений в контрольных точках
4. Убедиться, что размерность подпространства равна `n_free`

### Шаг 2.1.1.7: Обработка крайних случаев разложения

**Случай полного отсутствия ограничений (`m = 0`):**
- Весовой множитель вырождается: `W(x) = 1` (полином нулевой степени)
- Базисный полином: `P_int(x) = 0`
- Корректирующий полином: `Q(x) = F(x)`, степень `n`
- Специальная оптимизация: пропустить этапы, связанные с интерполяцией

**Случай максимального числа ограничений (`m = n + 1`):**
- Корректирующий полином вырождается: `deg_Q = -1` → `Q(x) ≡ 0`
- Единственное решение: `F(x) = P_int(x)`
- Предупреждение: «Аппроксимирующий и отталкивающий критерии не влияют на решение»
- Оптимизация: пропустить этап оптимизации, вернуть `P_int(x)` напрямую

**Случай избыточных ограничений (`m > n + 1`):**
- Теоретически невозможно удовлетворить все ограничения полиномом степени `n`
- Стратегия обработки:
  * Вариант A (строгий): вернуть ошибку «Система ограничений переопределена»
  * Вариант B (мягкий): решить задачу наименьших квадратов для интерполяционных условий
    - Требует модификации всей постановки задачи
    - Не рекомендуется без явного указания пользователя

### Шаг 2.1.1.8: Интеграция с последующими этапами алгоритма

**Подготовка интерфейса для оптимизатора:**
1. Определить вектор свободных параметров:
   - Размер: `n_free = n - m + 1`
   - Семантика: коэффициенты корректирующего полинома `Q(x)`

2. Спроектировать функцию преобразования параметров → значение функционала:
   - Вход: вектор `q[0..n_free-1]`
   - Выход: значение `J(q)` через разложение `F(x) = P_int(x) + Q_q(x)·W(x)`
   - Кэширование: предварительно вычислить `W(x_i)`, `W(y_j)` для всех точек данных

3. Спроектировать функцию вычисления градиента:
   - Аналитический градиент по параметру `q_k`:
     ```
     ∂J/∂q_k = 2·Σ_i [(F(x_i) - f(x_i))/σ_i] · φ_k(x_i)·W(x_i)
               - 2·Σ_j [B_j / (y_j^* - F(y_j))³] · φ_k(y_j)·W(y_j)
               + 2γ·∫ F''(x) · (φ_k(x)·W(x))'' dx
     ```
     где `φ_k(x)` — базисная функция для коэффициента `q_k`

**Генерация диагностического отчёта о разложении:**
- Сводная информация:
  * Размерность исходного пространства: `n + 1`
  * Число ограничений: `m`
  * Размерность подпространства решений: `n - m + 1`
  * Минимальное расстояние между узлами: `d_min`
- Рекомендации:
  * При `d_min < 0.001·(b - a)`: «Рассмотрите использование сплайнов вместо глобального полинома»
  * При `n - m + 1 > 20`: «Рассмотрите снижение степени полинома или объединение близких узлов»

Этот план обеспечивает строгое математическое обоснование параметризации, проверку всех необходимых условий применимости, подготовку структур данных для эффективной реализации и защиту от численных неустойчивостей на раннем этапе алгоритма. Разложение «базис + коррекция» исключает необходимость в методах условной оптимизации, сводя задачу к безусловной минимизации по уменьшенному числу параметров.