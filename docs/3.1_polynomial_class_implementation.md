## Подшаг 3.1: Реализация класса полинома — подробный план на C++

### Шаг 3.1.1: Архитектурное проектирование иерархии классов

**Основная структура иерархии:**
- **Базовый интерфейс `IPolynomial`** — абстрактный класс с чисто виртуальными методами:
  * `evaluate(x)` — вычисление значения
  * `first_derivative(x)` — первая производная
  * `second_derivative(x)` — вторая производная
  * `gradient_component(x, k)` — частная производная по коэффициенту `a_k`
- **Конкретная реализация `ConstrainedPolynomial`** — наследник, инкапсулирующий параметризацию с интерполяционными ограничениями (шаг 2.1)
- **Вспомогательный класс `PolynomialCache`** — для кэширования промежуточных вычислений

**Принцип разделения ответственности:**
- Класс полинома отвечает только за математические операции над функцией
- Веса, точки данных и компоненты функционала управляются внешним классом `MixedApproximationSolver`
- Это обеспечивает переиспользование полинома в других задачах и упрощает тестирование

### Шаг 3.1.2: Представление коэффициентов и выбор базиса

**Варианты хранения коэффициентов:**
- **Мономиальный базис (стандартный):**
  * Массив `coeffs[0..n]`, где `coeffs[k]` соответствует коэффициенту при `x^k`
  * Преимущество: простота понимания и отладки
  * Недостаток: численная неустойчивость при `n > 20`
  
- **Базис Чебышёва (рекомендуемый для высоких степеней):**
  * Коэффициенты относительно ортогональных полиномов `T_k(t)`, где `t ∈ [-1, 1]`
  * Требует преобразования координат: `t = 2·(x - a)/(b - a) - 1`
  * Преимущество: устойчивость к осцилляциям, равномерное распределение ошибки

**Стратегия гибридного представления:**
- Внутреннее хранение в базисе Чебышёва для численной устойчивости
- Предоставление методов преобразования в мономиальный базис для внешнего интерфейса
- Автоматический выбор базиса в зависимости от степени:
  * `n ≤ 15` — мономиальный базис
  * `n > 15` — базис Чебышёва с предупреждением о потенциальной неустойчивости

**Структура данных для коэффициентов:**
```cpp
struct PolynomialCoefficients {
    std::vector<double> values;      // собственно коэффициенты
    BasisType basis;                 // MONOMIAL или CHEBYSHEV
    double interval_a, interval_b;   // для базиса Чебышёва
    bool is_normalized;              // флаг нормализации интервала
};
```

### Шаг 3.1.3: Реализация метода `evaluate(x)` — схема Горнера

**Классическая схема Горнера для мономиального базиса:**
```
Результат = coeffs[n]
Для k от n-1 до 0:
    Результат = Результат * x + coeffs[k]
Возврат Результат
```
- Сложность: O(n) операций умножения и сложения
- Численная устойчивость: лучше прямого вычисления степеней

**Оптимизированная схема для базиса Чебышёва:**
- Использование рекуррентного соотношения: `T_{k+1}(t) = 2t·T_k(t) - T_{k-1}(t)`
- Алгоритм Клансена-Хорнера для ортогональных полиномов:
  ```
  b_{n+1} = b_{n+2} = 0
  Для k от n до 0:
      b_k = coeffs[k] + 2·t·b_{k+1} - b_{k+2}
  Результат = b_0 - t·b_1
  ```
- Преобразование результата обратно в исходный интервал при необходимости

**Численная защита в методе `evaluate()`:**
- Проверка на `NaN` и `±Inf` входного аргумента `x`
- Ограничение аргумента границами `[a, b]` с предупреждением при выходе за пределы
- Для очень больших `|x|` (> 1e6) применение масштабирования для предотвращения переполнения
- Логирование экстремальных значений результата (`|F(x)| > 1e10`) как потенциального признака неустойчивости

### Шаг 3.1.4: Реализация метода `second_derivative(x)`

**Аналитический подход для мономиального базиса:**
- Вторая производная полинома также является полиномом:
  ```
  F''(x) = Σ_{k=2..n} k·(k-1)·a_k·x^{k-2}
  ```
- Вычисление через модифицированную схему Горнера:
  * Предварительно вычислить коэффициенты второй производной: `d2_coeffs[k-2] = k·(k-1)·coeffs[k]`
  * Применить стандартную схему Горнера к `d2_coeffs`

**Рекуррентный подход для базиса Чебышёва:**
- Использование соотношения для производных полиномов Чебышёва:
  ```
  T_k'(t) = k·U_{k-1}(t)
  T_k''(t) = k·(k-1)·T_{k-2}(t) - k·t·U_{k-1}(t) / (1 - t²)  [для |t| < 1]
  ```
- Практическая реализация: численное дифференцирование с центральной разностью для упрощения:
  ```
  F''(x) ≈ (F(x+h) - 2·F(x) + F(x-h)) / h²
  где h = ε·max(1, |x|), ε ≈ 1e-5
  ```
- Компромисс: аналитический метод точнее, но сложнее; численный — проще и достаточно точен для регуляризации

**Оптимизация для регуляризационного члена:**
- Предварительное аналитическое вычисление интеграла `∫(F''(x))²dx` через коэффициенты:
  * Для мономиального базиса: `∫ x^p · x^q dx = (b^{p+q+1} - a^{p+q+1}) / (p+q+1)`
  * Построение матрицы `H_{kl} = ∫ φ_k''(x) φ_l''(x) dx`, где `φ_k` — базисные функции
  * Регуляризационный член вычисляется как квадратичная форма: `γ · a^T · H · a`
- Это исключает необходимость численного интегрирования на каждой итерации оптимизации

### Шаг 3.1.5: Реализация метода `gradient_component(x, k)`

**Математическая основа:**
- Для полинома `F(x) = Σ a_k · φ_k(x)` частная производная:
  ```
  ∂F(x)/∂a_k = φ_k(x)
  ```
- Для мономиального базиса: `∂F(x)/∂a_k = x^k`
- Для базиса Чебышёва: `∂F(x)/∂a_k = T_k(t(x))`

**Интеграция с градиентом функционала:**
- Метод `gradient_component()` возвращает только базисную функцию `φ_k(x)`
- Фактический градиент функционала `J` по коэффициенту `a_k` вычисляется внешним классом:
  ```
  ∂J/∂a_k = -2·Σ [ (f(x_i) - F(x_i)) / σ_i · φ_k(x_i) ]
            + 2·Σ [ B_j / |y_j^* - F(y_j)|³ · φ_k(y_j) ]
            + 2γ · Σ_l H_{kl} · a_l
  ```
- Преимущество разделения: класс полинома остаётся независимым от специфики функционала

**Эффективная реализация для мономиального базиса:**
- Кэширование степеней `x^k` при первом вызове для точки `x`:
  ```
  powers[0] = 1.0
  Для k от 1 до n:
      powers[k] = powers[k-1] * x
  ```
- Последующие вызовы `gradient_component(x, k)` возвращают `powers[k]` за O(1)
- Особенно эффективно при вычислении полного градиента (все `k` для фиксированного `x`)

### Шаг 3.1.6: Поддержка параметризации с интерполяционными ограничениями

**Интеграция с результатами шага 2.1:**
- Класс полинома хранит три компонента:
  * `P_int` — интерполяционный базис (барицентрические веса)
  * `W` — весовой множитель `Π(x - z_e)`
  * `Q` — корректирующий полином со свободными коэффициентами
  
**Ленивая оценка значения:**
```
F(x) = 
  если |x - z_e| < ε для некоторого e:
      вернуть f(z_e)  // точная интерполяция
  иначе:
      вернуть P_int.evaluate(x) + Q.evaluate(x) * W.evaluate(x)
```

**Особенности вычисления производных:**
- Вторая производная через правило Лейбница:
  ```
  F''(x) = P_int''(x) + Q''(x)·W(x) + 2·Q'(x)·W'(x) + Q(x)·W''(x)
  ```
- Производные `W'(x)`, `W''(x)` вычисляются аналитически один раз и кэшируются
- Производные `P_int'(x)`, `P_int''(x)` вычисляются через барицентрические формулы дифференцирования

**Градиент по свободным параметрам:**
- Градиент вычисляется только по коэффициентам `Q(x)` (размерность `n - m + 1`)
- Для коэффициента `q_k` при базисной функции `φ_k(x)`:
  ```
  ∂F(x)/∂q_k = φ_k(x) · W(x)
  ```
- Это упрощает оптимизацию, так как интерполяционные условия уже удовлетворены автоматически

### Шаг 3.1.7: Механизмы кэширования для повышения производительности

**Типы кэшей:**
- **Точечный кэш:** хранение `(x, F(x), F'(x), F''(x))` для недавно вычисленных точек
  * Реализация: `std::unordered_map` с хэшированием по квантованному значению `x`
  * Размер: ограничить 1000 элементами, удалять по LRU-политике
  
- **Кэш для точек данных:** предварительное вычисление `F(x_i)`, `W(x_i)` для всех `{x_i}`, `{y_j}`
  * Заполняется один раз перед началом оптимизации
  * Обновляется после каждой итерации изменения коэффициентов `q_k`
  
- **Кэш производных базиса:** таблица `φ_k(x_i)` для всех комбинаций базисных функций и точек
  * Размер: `(n+1) × N`, где N — общее число точек данных
  * Позволяет вычислять градиент за O(N) вместо O(n·N)

**Стратегия инвалидации кэшей:**
- При изменении коэффициентов полинома инвалидировать только кэши значений `F(x)`
- Кэши базисных функций `φ_k(x)` и весового множителя `W(x)` остаются валидными
- Для регуляризационной матрицы `H` использовать постоянный кэш (не зависит от коэффициентов)

### Шаг 3.1.8: Диагностические методы и валидация

**Встроенные проверки корректности:**
- Метод `validate_interpolation()` — верификация точного выполнения условий `F(z_e) = f(z_e)`
- Метод `check_stability()` — оценка численной устойчивости через анализ коэффициентов:
  * Отношение `max|a_k| / min|a_k|` (при > 1e10 — предупреждение)
  * Норма полинома на границах интервала
  
**Инструменты отладки:**
- Метод `to_string()` — текстовое представление полинома для логирования
- Метод `evaluate_debug(x)` — расширенная оценка с промежуточными значениями компонентов
- Статистика использования кэшей (попадания/промахи) для оптимизации производительности

**Тестирование численной точности:**
- Внутренний метод `self_test()` — проверка тождеств:
  * `F(x)` через прямую оценку vs через разложение `P_int + Q·W`
  * `F''(x)` через аналитическую формулу vs численное дифференцирование
  * Отклонение должно быть < `1e-10` для корректной реализации

### Шаг 3.1.9: Обработка крайних случаев и защита от ошибок

**Защита от переполнения:**
- При вычислении высоких степеней `x^k` проверять промежуточные результаты на `isfinite()`
- При обнаружении переполнения автоматически переключаться на логарифмическое представление
- Для `|x| > 100` и `n > 50` выдавать предупреждение о потенциальной неустойчивости

**Работа с отталкивающими точками:**
- Хотя непосредственная защита от деления на ноль реализуется на уровне функционала,
- Класс полинома предоставляет метод `distance_to_forbidden(x, y_forbidden)`:
  ```
  return fabs(evaluate(x) - y_forbidden)
  ```
- Внешний код использует этот метод для динамической адаптации шага оптимизации при приближении к барьеру

**Обработка вырожденных случаев:**
- Степень `n = 0` (константа): специализированная реализация без схемы Горнера
- Отсутствие свободных параметров (`n - m + 1 = 0`): полином полностью определён интерполяцией
- Все коэффициенты нулевые: возврат 0.0 без вычислений

Этот план обеспечивает создание гибкого, численно устойчивого и производительного класса полинома, полностью интегрированного с концепцией смешанной аппроксимации и автоматическим удовлетворением интерполяционных ограничений. Архитектура поддерживает как простые сценарии (низкие степени), так и сложные задачи (высокие степени с ограничениями), предоставляя необходимые инструменты для диагностики и оптимизации производительности.