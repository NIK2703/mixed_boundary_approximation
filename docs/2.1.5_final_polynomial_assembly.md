## Подшаг 2.1.5: Сборка итогового полинома `F(x)` — подробный план реализации на C++

### Шаг 2.1.5.1: Анализ стратегий сборки полинома

**Три возможные стратегии реализации:**

1. **Аналитическая сборка (явное построение коэффициентов):**
   - Полностью вычислить коэффициенты итогового полинома `F(x)` степени `n`
   - Преимущество: прямой доступ к коэффициентам для аналитических операций
   - Недостаток: катастрофическая потеря точности при `n > 20` из-за накопления ошибок округления при перемножении полиномов

2. **Ленивая оценка (вычисление «на лету»):**
   - Не строить явные коэффициенты, а вычислять значения через разложение:
     ```
     F(x) = P_int.evaluate(x) + Q.evaluate(x) * W.evaluate(x)
     ```
   - Преимущество: максимальная численная устойчивость, избегание промежуточных операций с высокими степенями
   - Недостаток: невозможность прямого доступа к коэффициентам для некоторых аналитических вычислений

3. **Гибридный подход (рекомендуемый):**
   - Использовать ленивую оценку для вычисления значений функционала и градиента
   - Вычислять коэффициенты только при необходимости (визуализация, экспорт результатов)
   - Для регуляризационного члена использовать аналитические формулы через компоненты разложения без явной сборки

### Шаг 2.1.5.2: Алгебраическая сборка коэффициентов (для случаев низкой степени)

**Алгоритм перемножения полиномов `Q(x) · W(x)`:**

1. Предварительные условия:
   - Степень `Q(x)`: `deg_Q = n - m`
   - Степень `W(x)`: `deg_W = m`
   - Степень произведения: `deg_QW = n`

2. Вычисление коэффициентов произведения через дискретную свёртку:
   - Для каждого индекса `k` от `0` до `n`:
     ```
     coeff_QW[k] = Σ_{i=0..min(k, deg_Q)} q_coeffs[i] · w_coeffs[k - i]
     ```
     где `q_coeffs[i]` — коэффициенты `Q(x)`, `w_coeffs[j]` — коэффициенты `W(x)`
   - Сложность: O(n·m) операций

3. Сложение с базисным полиномом:
   - Преобразовать `P_int(x)` из барицентрического представления в коэффициенты (если необходимо):
     * Для `m ≤ 10` — прямое раскрытие формулы Лагранжа
     * Для `m > 10` — использовать метод неопределённых коэффициентов с решением системы Вандермонда
   - Сложить коэффициенты: `F_coeffs[k] = P_int_coeffs[k] + coeff_QW[k]`

**Численная защита при сборке:**
- Перед сборкой проверить степень полинома:
  * Если `n ≤ 15` — разрешить аналитическую сборку
  * Если `15 < n ≤ 25` — разрешить с предупреждением и использованием `long double`
  * Если `n > 25` — запретить аналитическую сборку, использовать только ленивую оценку
- При сборке контролировать норму коэффициентов:
  * Если `max|F_coeffs[k]| > 1e100` — диагностировать численную неустойчивость
  * Предложить автоматический переход на ленивую оценку

### Шаг 2.1.5.3: Реализация ленивой оценки значений

**Архитектура вычислителя «на лету»:**

1. Интерфейс оценки значения в произвольной точке:
   - Метод `evaluate(double x)` выполняет три операции:
     ```
     value_P = interpolation_basis.evaluate(x)
     value_W = weight_polynomial.evaluate(x)
     value_Q = correction_polynomial.evaluate(x)
     return value_P + value_Q * value_W
     ```

2. Оптимизация через кэширование промежуточных результатов:
   - Для каждой точки данных `{x_i}` и `{y_j}` предварительно вычислить:
     * `W(x_i)`, `W(y_j)` — значения весового множителя
     * `P_int(x_i)`, `P_int(y_j)` — значения базисного полинома
   - При оценке `F(x_i)` требуется только вычисление `Q(x_i)`, что ускоряет расчёт в 2–3 раза

3. Параллельная оценка для множества точек:
   - Метод `evaluate_batch(const std::vector<double>& points, std::vector<double>& results)`
   - Использовать векторизацию (SIMD) для одновременной обработки 4–8 точек
   - Минимизировать количество обращений к памяти через локальность данных

**Численная стабилизация ленивой оценки:**
- При близости точки к корню весового множителя (`|x - z_e| < ε_root = 1e-12`):
  * Использовать разложение Тейлора для `W(x)` в окрестности корня:
    ```
    W(x) ≈ W'(z_e) · (x - z_e) + ½·W''(z_e)·(x - z_e)²
    ```
  * Это предотвращает потерю точности при вычитании близких чисел
- Контроль переполнения при умножении `Q(x)·W(x)`:
  * Если `|Q(x)| > 1e150` или `|W(x)| > 1e150` — масштабировать оба множителя с сохранением произведения

### Шаг 2.1.5.4: Вычисление производных для регуляризационного члена

**Аналитическое выражение второй производной через компоненты:**
```
F''(x) = P_int''(x) + Q''(x)·W(x) + 2·Q'(x)·W'(x) + Q(x)·W''(x)
```

**Стратегия вычисления каждой компоненты:**

1. **Вторая производная базисного полинома `P_int''(x)`:**
   - Для барицентрического представления использовать аналитическую формулу:
     ```
     P_int''(x) = [2·P_int'(x)·S₁(x) - P_int(x)·S₂(x) - S₃(x)] / S₀(x)
     где S_k(x) = Σ w_e·f(z_e)/(x - z_e)^k
     ```
   - Альтернатива: численное дифференцирование с адаптивным шагом при сложности аналитической формулы

2. **Производные корректирующего полинома `Q'(x)`, `Q''(x)`:**
   - Для мономиального базиса: прямое дифференцирование коэффициентов
   - Для базиса Чебышёва: использовать рекуррентные соотношения для производных полиномов Чебышёва
   - Кэшировать значения производных в узлах квадратуры для регуляризационного интеграла

3. **Производные весового множителя `W'(x)`, `W''(x)`:**
   - Использовать логарифмическое дифференцирование для численной устойчивости:
     ```
     W'(x) = W(x) · Σ 1/(x - z_e)
     W''(x) = W(x) · ([Σ 1/(x - z_e)]² - Σ 1/(x - z_e)²)
     ```
   - Предварительно вычислить и закэшировать суммы `Σ 1/(x - z_e)` и `Σ 1/(x - z_e)²` в узлах квадратуры

**Численное интегрирование регуляризационного члена:**
- Использовать квадратуру Гаусса-Лежандра с адаптивным числом узлов:
  * Базовое число узлов: `n_quad = max(10, 2·n + 1)` (гарантирует точное интегрирование полиномов степени `2n`)
  * Адаптивное уточнение: если относительное изменение интеграла при удвоении узлов `< 1e-8` — принять результат
- Для ускорения: предварительно вычислить значения `F''(x)` во всех узлах квадратуры и использовать векторизацию

### Шаг 2.1.5.5: Верификация корректности сборки

**Тест на выполнение интерполяционных условий:**
1. Для каждого узла `z_e` вычислить `F(z_e)` через ленивую оценку
2. Проверить отклонение: `|F(z_e) - f(z_e)| < ε_interp`, где `ε_interp = 1e-10·max(1, |f(z_e)|)`
3. При нарушении:
   - Диагностировать источник ошибки:
     * Если `|W(z_e)| > ε_w = 1e-12` — ошибка в весовом множителе
     * Если `|P_int(z_e) - f(z_e)| > ε_interp` — ошибка в базисном полиноме
   - Применить коррекцию: принудительно установить `F(z_e) = f(z_e)` с локальной модификацией `Q(x)`

**Тест на согласованность представлений:**
1. Выбрать 10 контрольных точек равномерно на `[a, b]`
2. Вычислить значения `F(x)` тремя способами:
   * Через ленивую оценку (основной метод)
   * Через аналитические коэффициенты (если доступны)
   * Через численное дифференцирование интегрального представления
3. Проверить согласованность с относительной погрешностью `< 1e-8`
4. При расхождении > 1% — диагностировать численную неустойчивость и рекомендовать снижение степени

**Тест на гладкость решения:**
1. Вычислить осцилляцию второй производной:
   ```
   oscillation = max_{x∈[a,b]} |F''(x)| / min_{x∈[a,b]} |F''(x)|
   ```
2. Если `oscillation > 1e6` — предупреждение о потенциальных осцилляциях (феномен Рунге)
3. Рекомендация: увеличить `γ` или перейти к сплайн-аппроксимации

### Шаг 2.1.5.6: Структуры данных для хранения итогового полинома

**Основная структура `CompositePolynomial`:**
```cpp
struct CompositePolynomial {
    // Компоненты разложения
    InterpolationBasis interpolation_basis;  // P_int(x)
    WeightPolynomial weight_polynomial;      // W(x)
    CorrectionPolynomial correction_poly;    // Q(x)
    
    // Флаги стратегии вычислений
    EvaluationStrategy eval_strategy;        // LAZY, ANALYTIC, HYBRID
    bool analytic_coeffs_valid;              // доступны ли коэффициенты F(x)
    
    // Аналитические коэффициенты (опционально)
    std::vector<double> analytic_coeffs;     // коэффициенты F(x), если вычислены
    
    // Кэшированные данные для ускорения
    struct EvaluationCache {
        std::vector<double> P_at_x;          // P_int(x_i)
        std::vector<double> W_at_x;          // W(x_i)
        std::vector<double> P_at_y;          // P_int(y_j)
        std::vector<double> W_at_y;          // W(y_j)
        std::vector<double> quad_points;     // узлы квадратуры
        std::vector<double> W_at_quad;       // W(x) в узлах квадратуры
        std::vector<double> W1_at_quad;      // W'(x) в узлах квадратуры
        std::vector<double> W2_at_quad;      // W''(x) в узлах квадратуры
    } cache;
    
    // Метаданные
    int total_degree;                        // n — степень итогового полинома
    int num_constraints;                     // m — число интерполяционных узлов
    double interval_a, interval_b;           // границы [a, b]
};
```

**Интерфейсные методы структуры:**
- `double evaluate(double x)` — вычисление значения `F(x)`
- `double evaluate_derivative(double x, int order)` — вычисление производной заданного порядка
- `double compute_regularization_term()` — вычисление интеграла `∫(F''(x))²dx`
- `bool build_analytic_representation()` — построение явных коэффициентов (с проверкой устойчивости)
- `void invalidate_cache()` — сброс кэша при изменении коэффициентов `Q(x)`

### Шаг 2.1.5.7: Обработка крайних случаев сборки

**Случай вырожденного корректирующего полинома (`deg_Q = -1`):**
- Возникает при `m = n + 1` (полная интерполяция)
- Специальная обработка:
  * Установить `Q(x) ≡ 0`
  * Итоговый полином: `F(x) = P_int(x)` напрямую
  * Отключить все операции с коррекцией и весовым множителем
  * Предупреждение: «Аппроксимирующий и отталкивающий критерии не влияют на решение»

**Случай отсутствия интерполяционных узлов (`m = 0`):**
- Весовой множитель: `W(x) = 1`
- Базисный полином: `P_int(x) = 0`
- Итоговый полином: `F(x) = Q(x)` напрямую
- Оптимизация: пропустить умножение на `W(x)` и сложение с `P_int(x)`

**Случай высокой степени (`n > 30`):**
- Запретить аналитическую сборку коэффициентов
- Использовать только ленивую оценку с повышенной точностью (`long double`)
- Ограничить число итераций оптимизации из-за высокой вычислительной сложности
- Рекомендовать переход к локальным базисам (кубические сплайны, B-сплайны)

**Случай близких корней весового множителя:**
- При минимальном расстоянии между узлами `d_min < 1e-8·(b - a)`:
  * Применить регуляризацию весового множителя через сглаживание корней
  * Заменить близкие корни на один корень кратности 2 с модифицированным разложением
  * Предупреждение о потенциальной неустойчивости решения

### Шаг 2.1.5.8: Интеграция с оптимизатором и вычислением функционала

**Подготовка к оптимизации:**
1. Предварительное вычисление кэшей:
   - Значений `P_int(x_i)`, `W(x_i)` для всех аппроксимирующих точек
   - Значений `P_int(y_j)`, `W(y_j)` для всех отталкивающих точек
   - Значений `W(x)`, `W'(x)`, `W''(x)` в узлах квадратуры для регуляризации

2. Построение функции-обёртки для оптимизатора:
   - Функция `objective_wrapper(const double* q, int n_free)`:
     * Принимает указатель на коэффициенты `Q(x)`
     * Вычисляет `F(x_i)` через кэшированные `P_int(x_i)` и `W(x_i)`
     * Собирает значение функционала по трём компонентам
     * Возвращает скалярное значение `J`
   - Функция `gradient_wrapper(const double* q, double* grad, int n_free)`:
     * Вычисляет градиент по аналитическим формулам с использованием кэшей
     * Применяет защиту от деления на ноль в отталкивающем члене

**Эффективность вычислений:**
- Без кэширования: каждая оценка функционала требует O((N_x + N_y + N_quad)·n) операций
- С кэшированием: сокращение до O((N_x + N_y)·deg_Q + N_quad·deg_Q) операций
- Ускорение: 5–20× в зависимости от соотношения `m/n` и числа точек данных

**Диагностика численных проблем во время оптимизации:**
- Мониторинг значений функционала:
  * Если `J → ∞` — вероятно, оптимизатор приблизился к барьеру отталкивания
  * Стратегия: уменьшить шаг оптимизации или временно снизить веса `B_j`
- Мониторинг градиента:
  * Если `||∇J|| > 1e10` — численная неустойчивость
  * Стратегия: переключиться на метод с адаптивным шагом или снизить степень полинома

Этот план обеспечивает гибкую и численно устойчивую сборку итогового полинома с автоматическим выбором оптимальной стратегии (ленивая оценка для высоких степеней, аналитическая сборка для низких), полной подготовкой всех необходимых компонентов для вычисления функционала и его градиента, и защитой от типичных численных проблем при работе с полиномами высокой степени.