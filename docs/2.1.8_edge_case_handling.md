## Подшаг 2.1.8: Обработка крайних случаев параметризации — подробный план реализации на C++

### Шаг 2.1.8.1: Классификация крайних случаев и стратегия обработки

**Иерархия крайних случаев по критичности:**

| Уровень | Тип случая | Действие | Примеры |
|---------|------------|----------|---------|
| **Критический** | Делает задачу математически неразрешимой | Прервать алгоритм с детальной диагностикой | `m > n + 1`, противоречивые узлы |
| **Специальный** | Требует модификации параметризации | Автоматическая адаптация структуры данных | `m = 0`, `m = n + 1`, кратные корни |
| **Предупредительный** | Ухудшает численную устойчивость | Продолжить с предупреждениями и рекомендациями | `n > 30`, близкие узлы, вырожденные данные |
| **Восстановимый** | Вызывает численные аномалии во время вычислений | Динамическая коррекция с откатом | переполнение, потеря точности |

**Общая стратегия обработки:**
1. Диагностика на этапе валидации входных данных (шаг 1.1)
2. Предварительная адаптация структур данных до построения параметризации
3. Верификация корректности адаптированной параметризации (шаг 2.1.6)
4. Динамический мониторинг во время оптимизации с механизмами восстановления

### Шаг 2.1.8.2: Случай отсутствия интерполяционных узлов (`m = 0`)

**Диагностика:**
- Проверка: `nodes.count == 0` после валидации входных данных
- Допустимость: математически корректно, но требует специальной обработки параметризации

**Адаптация параметризации:**
1. Модификация разложения:
   - Весовой множитель вырождается: `W(x) = 1` (константа)
   - Базисный полином вырождается: `P_int(x) = 0`
   - Итоговая формула упрощается: `F(x) = Q(x)` напрямую

2. Модификация структур данных:
   - В `WeightMultiplier` установить флаг `is_trivial = true`
   - Установить `degree = 0`, `coeffs = {1.0}`
   - Отключить все операции с корнями (пустой вектор корней)
   - В `InterpolationBasis` установить флаг `is_trivial = true`, `method = NONE`

3. Оптимизация вычислений:
   - Пропустить умножение на `W(x)` в оценке `F(x)`
   - Пропустить сложение с `P_int(x)`
   - Упростить градиент: `∂J/∂q_k = ∂J/∂F · φ_k(x)` без дополнительных множителей

**Верификация корректности:**
- Тест на тождественность: для случайных коэффициентов `q` проверить `F(x) == Q(x)` с точностью `1e-14`
- Тест на корректность градиента: сравнить численную и аналитическую производные

**Диагностическое сообщение:**
```
ИНФО: Отсутствуют интерполяционные узлы (m = 0).
      Задача сводится к регуляризованной аппроксимации без ограничений.
      Параметризация автоматически упрощена: F(x) = Q(x).
```

### Шаг 2.1.8.3: Случай полной интерполяции (`m = n + 1`)

**Диагностика:**
- Проверка: `nodes.count == total_degree + 1`
- Анализ: степень свободы `n_free = n - m + 1 = 0` — нет свободных параметров для оптимизации

**Адаптация параметризации:**
1. Модификация разложения:
   - Корректирующий полином вырождается: `Q(x) ≡ 0`
   - Итоговое решение единственно: `F(x) = P_int(x)`
   - Аппроксимирующий и отталкивающий критерии становятся неактивными

2. Модификация структур данных:
   - В `CorrectionPolynomial` установить `degree = -1`, `n_free = 0`
   - Установить флаг `is_degenerate = true`
   - Инициализировать пустой вектор коэффициентов `coeffs = {}`
   - В `CompositeParameterization` установить `state = DEGENERATE_SOLUTION`

3. Обработка функционала:
   - Значение функционала определяется только регуляризацией: `J = γ · ∫(P_int''(x))² dx`
   - Градиент по коэффициентам отсутствует (пустой вектор)
   - Оптимизация пропускается — решение уже определено однозначно

**Верификация корректности:**
- Тест на точную интерполяцию: `|F(z_e) - f(z_e)| < 1e-12` для всех узлов
- Тест на отсутствие свободы: попытка изменить «коэффициенты» не влияет на `F(x)`

**Диагностическое сообщение и рекомендации:**
```
ПРЕДУПРЕЖДЕНИЕ: Полная интерполяция (m = n + 1).
                Решение единственно определено интерполяционными условиями.
                Аппроксимирующий и отталкивающий критерии не влияют на результат.
                
Рекомендации:
  • Для учёта данных увеличьте степень полинома до n ≥ m
  • Для учёта отталкивания увеличьте степень полинома до n ≥ m + 1
  • Текущее решение: чистая интерполяция Лагранжа степени m-1
```

### Шаг 2.1.8.4: Случай избыточных ограничений (`m > n + 1`)

**Диагностика:**
- Проверка: `nodes.count > total_degree + 1`
- Анализ: система линейных ограничений переопределена, точное решение не существует

**Стратегии обработки (иерархия приоритетов):**

**Стратегия A (строгая, по умолчанию):**
- Сформировать критическую ошибку с детальной диагностикой:
  ```
  ОШИБКА: Система ограничений переопределена (m = 12, n = 10).
          Для полинома степени n требуется не более n+1 = 11 интерполяционных узлов.
          Рекомендуемые действия:
            1. Уменьшите число узлов до 11 или менее
            2. Увеличьте степень полинома до 11 или более
            3. Преобразуйте часть узлов в аппроксимирующие точки с высокими весами
  ```
- Прервать алгоритм на этапе валидации (шаг 1.1)

**Стратегия B (мягкая, по запросу пользователя):**
1. Преобразование задачи в условную аппроксимацию:
   - Выбрать подмножество `m' = n + 1` узлов для точной интерполяции
   - Оставшиеся `m - m'` узлов преобразовать в аппроксимирующие точки с весами `σ = 1e-6`
   - Критерий выбора узлов:
     * Приоритет 1: максимальное расстояние между выбранными узлами (равномерное покрытие)
     * Приоритет 2: сохранение узлов на границах интервала `[a, b]`
     * Приоритет 3: сохранение узлов с экстремальными значениями `f(z_e)`

2. Модификация входных данных:
   - Создать новый набор узлов `nodes_selected` размером `n + 1`
   - Добавить оставшиеся узлы в множество аппроксимирующих точек `{x_i}`
   - Залогировать преобразование для аудита

3. Продолжить алгоритм с модифицированными данными

**Верификация корректности:**
- Проверка размерности: `m' == n + 1` после преобразования
- Тест на качество аппроксимации «отброшенных» узлов:
  * Относительная ошибка должна быть `< 1%` при разумных весах
  * При больших ошибках — выдать предупреждение о потере точности

### Шаг 2.1.8.5: Случай кратных или близких корней весового множителя

**Диагностика близких корней:**
1. Вычислить попарные расстояния между нормализованными узлами:
   ```
   d_min = min_{e≠k} |z_e_norm - z_k_norm|
   ```
2. Критерии классификации:
   - **Близкие корни**: `d_min < ε_close = max(1e-8, 1e-3 / m)`
   - **Кратные корни** (теоретические): пользователь явно указал одинаковые координаты `z_e == z_k`
   - **Почти кратные**: `d_min < 1e-12` (машинная точность)

**Обработка близких корней (стратегия объединения):**
1. Алгоритм кластеризации узлов:
   - Построить граф смежности: ребро между узлами если `|z_e - z_k| < ε_cluster`
   - Найти связные компоненты (кластеры) через поиск в глубину
   - Для каждого кластера вычислить:
     * Центр кластера: `z_center = mean(z_e)` взвешенное по `|f(z_e)|`
     * Среднее значение: `f_center = mean(f(z_e))`
     * Мера разброса: `Δf = max|f(z_e) - f_center|`

2. Принятие решения для каждого кластера:
   - Если `Δf < ε_value = 1e-8 · max(1, |f_center|)`:
     * Объединить узлы в один с координатой `z_center` и значением `f_center`
     * Уменьшить эффективное число узлов `m_eff`
   - Иначе:
     * Сформировать критическую ошибку: «Противоречивые значения в близких узлах»
     * Предложить пользователю ручное разрешение конфликта

3. Модификация параметризации:
   - Перестроить `WeightMultiplier` с новым набором узлов
   - Обновить `InterpolationBasis` с объединёнными значениями
   - Пересчитать все кэши и матрицы

**Обработка теоретически кратных корней:**
1. Модификация разложения для корня кратности `p` в точке `z*`:
   ```
   W(x) = (x - z*)^p · W_remaining(x)
   F(x) = P_int(x) + Q(x) · (x - z*)^p · W_remaining(x)
   ```
2. Усиление интерполяционных условий:
   - Для кратного корня требуются дополнительные условия на производные:
     ```
     F(z*) = f(z*),  F'(z*) = f'(z*),  ...,  F^{(p-1)}(z*) = f^{(p-1)}(z*)
     ```
   - Если производные не заданы пользователем — использовать численное дифференцирование
   - Уменьшить степень свободного полинома: `deg_Q = n - m - (p - 1)`

3. Специальная реализация весового множителя:
   - Хранить кратные корни отдельно в структуре `MultipleRoot { double z; int multiplicity; }`
   - При оценке использовать разложение Тейлора в окрестности кратного корня для устойчивости

**Диагностическое сообщение:**
```
ИНФО: Обнаружены близкие узлы (мин. расстояние = 3.2e-05·(b-a)).
      Узлы [4, 5, 6] объединены в один с координатой z = 2.341.
      Эффективное число узлов уменьшено с 12 до 10.
      
ПРЕДУПРЕЖДЕНИЕ: Объединение узлов может снизить точность локальной аппроксимации.
                Рассмотрите увеличение степени полинома или использование сплайнов.
```

### Шаг 2.1.8.6: Случай высокой степени полинома (`n > 30`)

**Диагностика:**
- Проверка: `total_degree > 30`
- Анализ рисков:
  * Катастрофическая потеря точности при работе с коэффициентами
  * Осцилляции Рунге при интерполяции на равномерной сетке
  * Экспоненциальный рост вычислительной сложности

**Стратегия многоуровневой защиты:**

**Уровень 1: Предупреждение и рекомендации**
- Выдать предупреждение до начала вычислений:
  ```
  ПРЕДУПРЕЖДЕНИЕ: Высокая степень полинома (n = 35).
                  Риск численной неустойчивости и осцилляций Рунге.
                  
  Рекомендуемые альтернативы:
    • Использовать кубические сплайны (рекомендуется)
    • Использовать B-сплайны степени 3–5
    • Разбить интервал на сегменты и использовать локальные полиномы
  ```
- Предложить автоматический переход к сплайнам через флаг `auto_switch_to_splines = true`

**Уровень 2: Принудительные меры при продолжении**
1. Обязательное использование базиса Чебышёва:
   - Запретить мономиальный базис при `n > 15`
   - Автоматически переключить `correction.basis_type = CHEBYSHEV`

2. Ограничение представления весового множителя:
   - Запретить хранение коэффициентов `W(x)` при `m > 20`
   - Использовать только представление через корни

3. Повышенная точность вычислений:
   - Переключиться на арифметику `long double` для всех критических операций
   - Использовать компенсированную арифметику (алгоритм Кахана) для суммирования

4. Адаптивное ограничение итераций оптимизации:
   - Максимальное число итераций: `max_iter = min(100, 500 / n)`
   - Ранняя остановка при обнаружении осцилляций в градиенте

**Уровень 3: Автоматический переход к сплайнам (опционально)**
1. Критерий активации:
   - `n > 40` ИЛИ
   - `n > 25` И число узлов `m > 10` ИЛИ
   - пользователь установил флаг `prefer_splines = true`

2. Алгоритм преобразования:
   - Разбить интервал `[a, b]` на `K = max(5, n / 5)` сегментов
   - Построить кубический сплайн с условиями интерполяции в узлах
   - Преобразовать отталкивающие точки в локальные ограничения для соответствующих сегментов
   - Решить задачу оптимизации для вектора значений сплайна в узлах сетки

3. Преимущества сплайнов:
   - Локальность: изменение в одном сегменте не влияет на другие
   - Устойчивость: отсутствие осцилляций Рунге
   - Эффективность: линейная сложность вместо кубической

### Шаг 2.1.8.7: Случай вырожденных данных

**Типы вырожденных данных:**

1. **Константные значения интерполяции:**
   - Диагностика: `max|f(z_e) - mean(f)| < ε_const = 1e-12 · max(1, |mean(f)|)`
   - Обработка:
     * Базисный полином упрощается до константы: `P_int(x) = C`
     * Первые и вторые производные `P_int' = P_int'' = 0`
     * Регуляризационный член зависит только от коррекции: `∫(F'')² = ∫(Q''·W + 2Q'·W' + Q·W'')²`

2. **Линейная зависимость значений:**
   - Диагностика: ранг матрицы Вандермонда `< m` при допуске `ε_rank = 1e-10`
   - Обработка:
     * Понизить эффективную степень интерполяционного полинома до `m_eff - 1`
     * Увеличить число свободных параметров: `n_free = n - m_eff + 1`
     * Выдать предупреждение о вырожденности данных

3. **Пустые множества точек:**
   - Аппроксимирующие точки отсутствуют (`N_x = 0`):
     * Задача сводится к минимизации отталкивающего + регуляризационного членов
     * Начальное приближение: `Q(x) = 0` (чистая интерполяция)
     * Риск: решение может быть неединственным без аппроксимирующего критерия
   - Отталкивающие точки отсутствуют (`N_y = 0`):
     * Стандартная регуляризованная интерполяция/аппроксимация
     * Нет необходимости в защите от барьеров
   - Оба множества пусты (`N_x = N_y = 0`):
     * Решение определяется только минимизацией кривизны: `F''(x) = 0`
     * Итог: линейная функция, проходящая через интерполяционные узлы
     * При `m > 2` — задача может быть неразрешимой (противоречивые узлы на прямой)

**Верификация корректности:**
- Тест на константность: для константных данных проверить `max|F'(x)| < 1e-10` на сетке
- Тест на линейность: для линейных данных проверить `max|F''(x)| < 1e-10`

### Шаг 2.1.8.8: Динамическая обработка численных аномалий во время оптимизации

**Мониторинг критических метрик на каждой итерации:**

1. **Переполнение/исчезновение значений:**
   - Контроль: `isfinite(F(x))` для всех точек данных
   - При обнаружении `Inf` или `NaN`:
     * Откат к предыдущей итерации с уменьшенным шагом (`α = α / 2`)
     * Если повторяется 3 раза подряд — аварийная остановка с диагностикой
     * Анализ: вероятно, оптимизатор приблизился к барьеру отталкивания

2. **Взрывной рост градиента:**
   - Контроль: `||∇J|| < 1e10 · J_initial`
   - При превышении:
     * Применить обрезку градиента (gradient clipping): `∇J = ∇J · min(1.0, threshold / ||∇J||)`
     * Уменьшить шаг оптимизации
     * Выдать предупреждение о потенциальной неустойчивости

3. **Осцилляции параметров:**
   - Контроль: анализ последовательности `q_k^{(t)}` на предмет периодичности
   - При обнаружении осцилляций:
     * Применить импульсный метод с затуханием (momentum decay)
     * Или переключиться на метод доверительных областей (trust region)

**Стратегия восстановления после сбоя:**

1. Сохранение контрольных точек:
   - Каждые 10 итераций сохранять копию параметров `q_backup`
   - Хранить историю последних 5 контрольных точек

2. Алгоритм отката:
   ```
   при сбое на итерации t:
       для i от 4 до 0 (обратный порядок):
           загрузить параметры из контрольной точки t - 10·i
           уменьшить шаг оптимизации в 2^i раз
           попробовать 1 итерацию
           если успешно → продолжить оптимизацию
       если все попытки неудачны → аварийная остановка
   ```

3. Адаптивная модификация параметров задачи:
   - Временное уменьшение весов отталкивания: `B_j = B_j / 10`
   - Увеличение регуляризации: `γ = γ · 10`
   - После стабилизации постепенно вернуть исходные значения

### Шаг 2.1.8.9: Интеграция обработки крайних случаев в основной алгоритм

**Точка интеграции 1: Этап валидации (шаг 1.1)**
- Выполнить диагностику всех критических случаев
- Для критических случаев — прервать алгоритм с детальным отчётом
- Для специальных случаев — применить адаптацию и продолжить
- Для предупредительных случаев — залогировать предупреждения и продолжить

**Точка интеграции 2: Этап построения параметризации (шаги 2.1.2–2.1.5)**
- Перед построением каждого компонента проверить применимость стандартного алгоритма
- При необходимости применить специализированный алгоритм для крайнего случая
- После построения выполнить расширенную верификацию (шаг 2.1.6) с учётом специфики случая

**Точка интеграции 3: Этап оптимизации**
- Инициализировать монитор численных аномалий
- На каждой итерации проверять критические метрики
- При обнаружении аномалий применить стратегию восстановления
- Вести журнал событий для пост-анализа

**Структура диагностического отчёта об обработке крайних случаев:**
```
ОТЧЁТ ОБРАБОТКИ КРАЙНИХ СЛУЧАЕВ
================================
Исходные параметры:
  • Степень полинома: n = 15
  • Число узлов интерполяции: m = 16
  • Число аппроксимирующих точек: N_x = 42
  • Число отталкивающих точек: N_y = 8

Обнаруженные крайние случаи:
  [КРИТИЧЕСКИЙ] Переопределённая система ограничений (m = 16 > n + 1 = 16)
                → Стратегия: уменьшение m до 15 через объединение близких узлов
  
  [ПРЕДУПРЕДИТЕЛЬНЫЙ] Близкие узлы (мин. расстояние = 0.0023·(b-a))
                      → Стратегия: объединение узлов 7 и 8
  
Применённые адаптации:
  1. Узлы [7, 8] объединены в один с координатой z = 3.412
  2. Эффективное число узлов уменьшено с 16 до 15
  3. Параметризация перестроена с deg_Q = 1
  
Результат верификации:
  • Точность интерполяции: max|δ| = 2.1e-13 ✓
  • Полнота пространства: ранг = 2, ожидаемо = 2 ✓
  • Устойчивость: cond(G) = 3.7e+02 ✓
  
Статус: ПАРАМЕТРИЗАЦИЯ КОРРЕКТНА, готова к оптимизации
```

Этот план обеспечивает всестороннюю обработку всех возможных крайних случаев параметризации с многоуровневой стратегией защиты, автоматической адаптацией структур данных, динамическим мониторингом во время оптимизации и подробной диагностикой для принятия обоснованных решений. Обработка интегрирована в основной алгоритм на всех критических этапах, что гарантирует устойчивость и надёжность работы даже при некорректных или вырожденных входных данных.