## Подшаг 4.3: Критерии останова оптимизации — подробный план реализации на C++

### Шаг 4.3.1: Классификация критериев останова и их комбинирование

**Типы критериев останова:**
- **Абсолютные:** основаны на фиксированных пороговых значениях (например, `||∇J|| < 1e-6`)
- **Относительные:** нормированы на начальные или характерные значения (например, `|ΔJ|/|J| < 1e-8`)
- **Структурные:** основаны на поведении последовательности итераций (осцилляции, застывание)
- **Ресурсные:** ограничения по времени или числу итераций

**Логика комбинирования критериев:**
- **Основное правило:** Остановка выполняется при выполнении **любого** из критериев сходимости ИЛИ исчерпания ресурсов
  ```
  ОСТАНОВИТЬ ⇔ (КРИТЕРИЙ_СХОДИМОСТИ_1 ИЛИ ... ИЛИ КРИТЕРИЙ_СХОДИМОСТИ_K) 
                ИЛИ (ИСЧЕРПАНИЕ_РЕСУРСОВ)
  ```
- **Иерархия приоритетов:**
  1. Численные аварии (`NaN/Inf`) — немедленная остановка с возвратом лучшего решения
  2. Ресурсные ограничения — остановка с предупреждением о неполном схождении
  3. Критерии сходимости — штатная остановка с подтверждением качества решения
  4. Диагностические критерии (осцилляции) — остановка с рекомендациями по коррекции параметров

### Шаг 4.3.2: Критерий останова по относительному изменению функционала

**Математическая формулировка:**
```
Критерий выполняется, если:
  |J_k - J_{k-1}| / max(|J_k|, J_scale) < ε_J
где:
  J_k — значение функционала на итерации k
  J_scale = max(1.0, 0.1·|J_initial|) — масштаб для нормировки
  ε_J = 1e-8 — порог сходимости (настраиваемый параметр)
```

**Устойчивая реализация с фильтрацией шума:**
1. **Скользящее окно для усреднения:**
   - Хранить последние `W = 5` значений функционала в циклическом буфере
   - Вычислять медиану окна `J_median` вместо последнего значения для устойчивости к выбросам
   - Использовать разность между медианами двух последовательных окон:
     ```
     ΔJ_window = |median(J_{k-W+1}..J_k) - median(J_{k-2W+1}..J_{k-W})|
     ```

2. **Адаптивный порог для барьерных задач:**
   - При наличии сильных барьеров (`max(B_j) > 100`) функционал может иметь «плато» с медленной сходимостью
   - Динамическая коррекция порога:
     ```
     ε_J_effective = ε_J · max(1.0, 0.1 · log10(max(B_j) / avg(σ_i)))
     ```
   - Это предотвращает преждевременную остановку вблизи барьеров, где сходимость естественно замедляется

3. **Защита от ложных срабатываний на плато:**
   - Требовать выполнения критерия на `N_plateau = 3` последовательных итерациях
   - Дополнительно проверять монотонность убывания:
     ```
     если J_k > J_{k-1} + 1e-12·|J_k| для 2+ последовательных итераций:
         сбросить счётчик выполнения критерия
     ```

### Шаг 4.3.3: Критерий останова по норме градиента

**Математическая формулировка:**
```
Критерий выполняется, если:
  ||∇J_k||_2 / max(||∇J_initial||_2, G_scale) < ε_grad
где:
  ||∇J_k||_2 — евклидова норма градиента на итерации k
  G_scale = 1.0 — базовый масштаб
  ε_grad = 1e-6 — порог сходимости (настраиваемый параметр)
```

**Расширенная версия с учётом структуры градиента:**
1. **Компонентный анализ градиента:**
   - Разделить градиент на три компонента (шаг 3.3):
     * `g_approx` — градиент аппроксимирующего члена
     * `g_repulse` — градиент отталкивающего члена  
     * `g_reg` — градиент регуляризации
   - Вычислить относительные нормы:
     ```
     r_approx = ||g_approx|| / ||∇J||
     r_repulse = ||g_repulse|| / ||∇J||
     r_reg = ||g_reg|| / ||∇J||
     ```

2. **Условие сходимости с балансом компонент:**
   - Основной критерий: `||∇J|| < ε_grad · max(||∇J_initial||, 1.0)`
   - Дополнительное условие баланса (предотвращает «застывание» в неоптимальной точке):
     ```
     если (r_repulse > 0.9 ИЛИ r_reg > 0.9) И ||∇J|| < 10·ε_grad:
         // Градиент доминируется одной компонентой — продолжить оптимизацию
         критерий_не_выполнен = ИСТИНА
     ```
   - Это гарантирует, что оптимизация завершается только при балансе всех критериев задачи

3. **Адаптация к масштабу задачи:**
   - Для задач с сильными барьерами (`max(B_j) > 1000`) градиент вблизи минимума может оставаться большим из-за крутого барьера
   - Коррекция порога:
     ```
     ε_grad_effective = ε_grad · (1.0 + 0.01 · log10(max(B_j)))
     ```

### Шаг 4.3.4: Критерий останова по максимальному числу итераций

**Базовая формулировка:**
```
Критерий выполняется, если: k ≥ max_iter
где max_iter — максимальное допустимое число итераций
```

**Адаптивное определение лимита итераций:**
1. **Эмпирическая формула на основе размерности:**
   ```
   max_iter_base = 100 + 20 · n_free
   где n_free = n - m + 1 — число свободных параметров
   ```

2. **Коррекция на сложность задачи:**
   - Учёт числа барьеров:
     ```
     factor_barriers = 1.0 + 0.05 · min(20, N_repulse)  // до 2× замедление для 20+ барьеров
     ```
   - Учёт силы барьеров:
     ```
     β = max(B_j) / avg(σ_i)
     factor_strength = 1.0 + 0.2 · log10(max(1.0, β))    // до 1.6× для β=1000
     ```
   - Итоговый лимит:
     ```
     max_iter = max_iter_base · factor_barriers · factor_strength
     max_iter = min(max_iter, 5000)  // абсолютный потолок для практических задач
     ```

3. **Динамическое продление лимита при прогрессе:**
   - Если за последние `Δk = 50` итераций функционал уменьшился более чем на 5%:
     ```
     если (J_{k-50} - J_k) / J_{k-50} > 0.05:
         max_iter = max(max_iter, k + 100)  // продлить лимит на 100 итераций
     ```
   - Ограничение: не более 3 продлений за одну оптимизацию

### Шаг 4.3.5: Критерий останова по времени выполнения

**Реализация таймера:**
1. **Точное измерение времени:**
   - Использовать `std::chrono::high_resolution_clock` для кроссплатформенной точности
   - Фиксировать время старта оптимизации один раз в начале
   - Проверять истечение времени каждые `N_check = 10` итераций для минимизации накладных расходов

2. **Адаптивный таймаут:**
   - Базовый таймаут: `timeout_base = 300.0` секунд (5 минут)
   - Коррекция на размерность задачи:
     ```
     timeout = timeout_base · (1.0 + 0.1 · n_free)
     timeout = min(timeout, 3600.0)  // максимум 1 час
     ```

3. **Мягкая остановка при приближении к таймауту:**
   - При достижении 90% таймаута:
     * Уменьшить параметр памяти L-BFGS (`m_lbfgs ← m_lbfgs / 2`) для ускорения итераций
     * Отключить дорогие диагностические проверки
   - При достижении 98% таймаута:
     * Выполнить одну финальную итерацию с минимально возможным шагом
     * Немедленно остановиться и вернуть текущее решение

### Шаг 4.3.6: Диагностические критерии: обнаружение проблем сходимости

**Критерий «осцилляций» (циклическое поведение):**
1. **Обнаружение через автокорреляцию:**
   - Вычислить коэффициент автокорреляции первого порядка для последних `W = 20` значений `J`:
     ```
     ρ = Σ_{i=1}^{W-1} (J_{k-i} - μ)·(J_{k-i-1} - μ) / Σ_{i=1}^{W} (J_{k-i} - μ)²
     где μ — среднее значение окна
     ```
   - Если `ρ < -0.7` — сильная отрицательная корреляция (осцилляции)

2. **Обнаружение через стандартное отклонение:**
   - Вычислить относительное стандартное отклонение последних `W` значений:
     ```
     σ_rel = std(J_{k-W+1}..J_k) / |J_k|
     ```
   - Если `σ_rel > 0.1` при `||∇J|| < 10·ε_grad` — осцилляции вблизи минимума

3. **Действия при обнаружении осцилляций:**
   - Уменьшить начальный шаг линейного поиска: `α_initial ← 0.3 · α_initial`
   - Увеличить параметр регуляризации: `γ ← 2.0 · γ` (временно, только для текущей итерации)
   - Продолжить оптимизацию с модифицированными параметрами
   - Если осцилляции сохраняются более 50 итераций — остановиться с кодом «ОСЦИЛЛЯЦИИ»

**Критерий «застывания» (отсутствие прогресса):**
1. **Обнаружение через анализ тренда:**
   - Вычислить линейную регрессию `J(i) = a·i + b` для последних `W = 100` итераций
   - Если наклон `|a| < 1e-12 · |J_k| / W` — отсутствие значимого тренда

2. **Обнаружение через сравнение с историческим минимумом:**
   - Хранить глобальный минимум `J_best` и итерацию его достижения `k_best`
   - Если `k - k_best > 200` И `J_k > J_best · 1.001` — застывание

3. **Действия при застывании:**
   - Применить «толчок» — случайное возмущение параметров:
     ```
     δq_k ~ N(0, 0.01 · |q_k| + 1e-6)
     q_k ← q_k + δq_k
     ```
   - Сбросить историю L-BFGS (очистить буфер коррекций)
   - Продолжить оптимизацию; если застывание повторяется 3 раза — остановиться

**Критерий «расходимости» (ухудшение решения):**
1. **Обнаружение катастрофического роста:**
   - Если `J_k > 100 · J_initial` — немедленная остановка
   - Если `J_k` содержит `NaN` или `Inf` — немедленная остановка

2. **Обнаружение постепенной расходимости:**
   - Если `J_k > 10 · J_best` И `(J_k - J_{k-10}) / J_{k-10} > 0.5` — устойчивый рост
   - Действие: вернуться к лучшему решению `q_best`, уменьшить шаг оптимизатора в 10 раз, продолжить

### Шаг 4.3.7: Финальная валидация перед остановом

**Обязательные проверки качества решения:**
1. **Численная корректность:**
   - Отсутствие `NaN/Inf` в коэффициентах и значениях полинома на сетке из 1000 точек на `[a, b]`
   - Ограниченность значений: `|F(x)| < 1e10` для всех `x ∈ [a, b]`

2. **Выполнение интерполяционных условий:**
   - `|F(z_e) - f(z_e)| < 1e-10` для всех узлов `e = 1..m`
   - При нарушении: применить проекционную коррекцию (шаг 2.1) и повторить проверку

3. **Безопасность относительно барьеров:**
   - `|F(y_j) - y_j^*| > ε_safe = 1e-8` для всех отталкивающих точек
   - При нарушении: выполнить один шаг градиентного подъёма по отталкивающему члену

4. **Физическая правдоподобность:**
   - Отсутствие экстремальных осцилляций: проверка через 10 контрольных точек между узлами данных
   - Если `max|F(x)| > 100 · max|f(x_i)|` — предупреждение о потенциальной неустойчивости

**Принятие решения об останове:**
```
ЕСЛИ (выполнены критерии сходимости) И (прошла финальная валидация):
    статус = СОШЁЛСЯ
    вернуть текущее решение

ИНАЧЕ ЕСЛИ (исчерпаны ресурсы) И (решение удовлетворяет минимальным требованиям):
    статус = ДОСТИГНУТ_ЛИМИТ (с предупреждением)
    вернуть текущее решение

ИНАЧЕ:
    статус = ОШИБКА_СХОДИМОСТИ
    вернуть лучшее найденное решение (не текущее!)
```

### Шаг 4.3.8: Генерация диагностического отчёта об останове

**Структура отчёта:**
```
Оптимизация завершена: СОШЛАСЬ (итерация 87 из 1000, время 12.3 с)

Критерии останова:
  • Относительное изменение функционала: 4.2e-9 < 1e-8 ✓
  • Норма градиента: 3.1e-7 < 1e-6 ✓
  • Макс. итерации: 87 < 1000 (не достигнуто)
  • Таймаут: 12.3 с < 300 с (не достигнут)

Качество решения:
  • Значение функционала: J = 5.1942 (улучшение на 87.3% от начального)
  • Выполнение интерполяции: ТОЧНО (макс. отклонение 2.3e-14)
  • Безопасность барьеров: ОК (мин. расстояние 0.123 > 1e-8)
  • Баланс критериев: аппроксимация=45.2%, отталкивание=36.1%, регуляризация=18.7%

Диагностика сходимости:
  • Прогресс за последние 10 итераций: -0.02% (стабилизация)
  • Осцилляции: отсутствуют (σ_rel = 1.2e-4)
  • Застывание: нет (линейный тренд значимый)
```

**Рекомендации при неполном схождении:**
- При остановке по лимиту итераций: «Увеличьте max_iter до 1500 для достижения полной сходимости»
- При остановке по времени: «Упростите задачу (уменьшите степень полинома) или увеличьте таймаут»
- При осцилляциях: «Уменьшите веса барьеров B_j или увеличьте параметр регуляризации γ»

Этот план обеспечивает надёжную, адаптивную и диагностически прозрачную систему критериев останова, учитывающую специфику невыпуклой оптимизации со сложными барьерными условиями. Подход сочетает математически обоснованные критерии с практическими механизмами диагностики проблем и автоматического восстановления, гарантируя возврат качественного решения даже в сложных случаях.